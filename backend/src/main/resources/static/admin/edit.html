<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>코스 편집 - 런세권</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f5f5f5;
        }

        .container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .header {
            background: white;
            color: #2d3748;
            padding: 20px 30px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 22px;
            font-weight: 600;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .back-button, .save-button {
            padding: 10px 20px;
            border: 1px solid #e2e8f0;
            background: white;
            color: #2d3748;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .back-button:hover {
            background: #f7fafc;
            border-color: #cbd5e0;
        }

        .save-button {
            background: #2d3748;
            color: white;
            border-color: #2d3748;
        }

        .save-button:hover {
            background: #1a202c;
        }

        .save-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .content {
            display: flex;
            height: 70vh;
            overflow: hidden;
        }

        .map-section {
            flex: 3;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .map-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            max-width: 300px;
        }

        .map-controls h3 {
            margin-bottom: 15px;
            color: #2d3748;
            font-size: 18px;
        }

        .map-controls p {
            font-size: 14px;
            color: #718096;
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .control-button {
            padding: 10px 20px;
            border: none;
            background: #2d3748;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
            width: 100%;
            margin-top: 10px;
        }

        .control-button:hover {
            background: #1a202c;
        }

        .control-button:active {
            transform: scale(0.98);
        }

        .control-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .control-button.secondary {
            background: #e2e8f0;
            color: #2d3748;
        }

        .control-button.secondary:hover {
            background: #cbd5e0;
        }

        .info-section {
            flex: 1;
            background: white;
            overflow-y: auto;
            border-left: 1px solid #e2e8f0;
            padding: 20px;
        }

        .info-section h2 {
            color: #2d3748;
            font-size: 20px;
            margin-bottom: 20px;
        }

        .course-info {
            margin-bottom: 20px;
        }

        .info-item {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e2e8f0;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-label {
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 14px;
            color: #2d3748;
        }

        .info-value.editable {
            width: 100%;
        }

        .info-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            color: #2d3748;
            transition: all 0.3s ease;
            outline: none;
        }

        .info-input:focus {
            border-color: #a0aec0;
        }

        .info-select {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            color: #2d3748;
            transition: all 0.3s ease;
            outline: none;
            background-color: white;
            cursor: pointer;
        }

        .info-select:focus {
            border-color: #a0aec0;
        }

        .info-select:hover {
            border-color: #cbd5e0;
        }

        .segment-list {
            margin-top: 20px;
        }

        .segment-item {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .segment-header {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .incline-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }

        .incline-badge.UPHILL {
            background: #fed7d7;
            color: #c53030;
        }

        .incline-badge.FLAT {
            background: #c6f6d5;
            color: #276749;
        }

        .incline-badge.DOWNHILL {
            background: #bee3f8;
            color: #2c5282;
        }

        .coordinate-count {
            font-size: 12px;
            color: #718096;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #718096;
        }

        .error-message {
            background: #fed7d7;
            color: #c53030;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .success-message {
            background: #c6f6d5;
            color: #276749;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .marker-dragging {
            cursor: move;
        }

        /* 영역 선택 스타일 */
        .selection-box {
            position: absolute;
            border: 2px solid #4A90E2;
            background-color: rgba(74, 144, 226, 0.2);
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        .coordinates-section {
            background: white;
            padding: 30px;
            border-top: 2px solid #e2e8f0;
        }

        .coordinates-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .coordinates-title {
            font-size: 18px;
            font-weight: 700;
            color: #2d3748;
        }

        .bulk-actions {
            display: flex;
            gap: 10px;
        }

        .bulk-button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .bulk-button.primary {
            background: #2d3748;
            color: white;
        }

        .bulk-button.primary:hover {
            background: #1a202c;
        }

        .bulk-button.secondary {
            background: #e2e8f0;
            color: #2d3748;
        }

        .bulk-button.secondary:hover {
            background: #cbd5e0;
        }

        .bulk-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .coordinates-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 13px;
        }

        .coordinates-table thead {
            background: #f7fafc;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .coordinates-table th {
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            color: #4a5568;
            border-bottom: 2px solid #e2e8f0;
        }

        .coordinates-table td {
            padding: 10px 8px;
            border-bottom: 1px solid #e2e8f0;
            color: #2d3748;
        }

        .coordinates-table tr:hover {
            background: #f7fafc;
        }

        .coordinates-table tr.selected {
            background: #e6f0ff;
        }

        .coord-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .coord-number {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #2d3748;
            font-weight: 600;
        }

        .coord-value {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
        }

        .coord-edit-btn {
            padding: 4px 12px;
            border: 1px solid #2d3748;
            background: white;
            color: #2d3748;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .coord-edit-btn:hover {
            background: #2d3748;
            color: white;
        }

        .segment-group-header {
            background: #edf2f7;
            font-weight: 700;
            color: #2d3748;
        }

        .select-all-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #4a5568;
            cursor: pointer;
        }

        /* 모달 스타일 */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            font-size: 20px;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #718096;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: #e2e8f0;
            color: #2d3748;
        }

        .modal-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .modal-form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .modal-label {
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
        }

        .modal-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            color: #2d3748;
            transition: all 0.3s ease;
            outline: none;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .modal-input:focus {
            border-color: #a0aec0;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .modal-button {
            flex: 1;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-button.primary {
            background: #2d3748;
            color: white;
        }

        .modal-button.primary:hover {
            background: #1a202c;
        }

        .modal-button.secondary {
            background: #e2e8f0;
            color: #2d3748;
        }

        .modal-button.secondary:hover {
            background: #cbd5e0;
        }

        .modal-button.danger {
            background: #e53e3e;
            color: white;
        }

        .modal-button.danger:hover {
            background: #c53030;
        }

        /* 선택 해제 버튼 */
        .clear-selection-button {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            padding: 12px 24px;
            background: white;
            color: #2d3748;
            border: 2px solid #2d3748;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: none;
        }

        .clear-selection-button:hover {
            background: #2d3748;
            color: white;
        }

        .clear-selection-button:active {
            transform: scale(0.98);
        }

        .clear-selection-button.visible {
            display: block;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>코스 편집</h1>
        <div class="header-buttons">
            <button class="save-button" onclick="saveCourse()">저장</button>
            <button class="back-button" onclick="window.history.back()">← 뒤로 가기</button>
        </div>
    </div>
    <div class="content">
        <div class="map-section">
            <div id="map"></div>
            <div id="selection-box" class="selection-box"></div>
            <button id="clear-selection-btn" class="clear-selection-button" onclick="clearAllSelections()">선택 해제 (ESC)</button>
            <div class="map-controls">
                <h3>편집 가이드</h3>
                <p>지도 위의 마커를 드래그하여 코스 좌표를 수정할 수 있습니다.</p>
                <p><strong>Shift + 클릭</strong>으로 마커를 다중 선택하고, 선택된 마커를 함께 드래그할 수 있습니다.</p>
                <p>변경사항은 저장 버튼을 눌러야 저장됩니다.</p>
                <button class="control-button secondary" onclick="resetChanges()">변경사항 초기화</button>
            </div>
        </div>
        <div class="info-section">
            <h2>코스 정보</h2>
            <div id="message-container"></div>
            <div class="loading" id="course-info">코스 정보를 불러오는 중...</div>
        </div>
    </div>
    <div class="coordinates-section" id="coordinates-container" style="display: none;">
        <div class="loading">좌표 목록을 불러오는 중...</div>
    </div>
</div>

<!-- 좌표 수정 모달 -->
<div class="modal-overlay" id="coordinate-edit-modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>좌표 수정</span>
            <button class="modal-close" onclick="closeCoordinateModal()">&times;</button>
        </div>
        <div class="modal-form">
            <div class="modal-form-group">
                <label class="modal-label" for="modal-latitude">위도 (Latitude)</label>
                <input class="modal-input" id="modal-latitude" placeholder="예: 37.566535" step="0.000001" type="number">
            </div>
            <div class="modal-form-group">
                <label class="modal-label" for="modal-longitude">경도 (Longitude)</label>
                <input class="modal-input" id="modal-longitude" placeholder="예: 126.978000" step="0.000001"
                       type="number">
            </div>
            <div class="modal-form-group">
                <label class="modal-label" for="modal-elevation">고도 (Elevation, m)</label>
                <input class="modal-input" id="modal-elevation" placeholder="예: 15.5" step="0.1" type="number">
            </div>
            <div class="modal-actions">
                <button class="modal-button danger" onclick="deleteCoordinateFromModal()">삭제</button>
                <button class="modal-button secondary" onclick="closeCoordinateModal()">취소</button>
                <button class="modal-button primary" onclick="saveCoordinateFromModal()">확인</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script src="//dapi.kakao.com/v2/maps/sdk.js?appkey=KAKAO_API_KEY_PLACEHOLDER" type="text/javascript"></script>
<script>
    // URL에서 코스 ID 추출
    const urlParams = new URLSearchParams(window.location.search);
    const courseId = urlParams.get('id');

    if (!courseId) {
        alert('코스 ID가 지정되지 않았습니다.');
        window.history.back();
    }

    let map;
    let course = null;
    let markers = [];
    let polylines = [];
    let originalCourse = null;
    let isInitialLoad = true; // 초기 로드 여부 플래그
    let selectedCoordinates = new Set(); // 선택된 좌표 (seg-idx_coord-idx 형식)
    let currentEditingCoord = null; // 현재 수정 중인 좌표 {segIdx, coordIdx}
    let isShiftPressed = false; // Shift 키 눌림 상태
    let isDraggingMultiple = false; // 다중 마커 드래그 중 상태
    let dragStartPosition = null; // 드래그 시작 위치
    let selectedMarkersInitialPositions = new Map(); // 선택된 마커들의 초기 위치 저장
    let dragAnimationFrameId = null; // 드래그 애니메이션 프레임 ID
    let currentDraggingMarker = null; // 현재 드래그 중인 마커

    // 영역 선택 관련 변수
    let isAreaSelecting = false; // 영역 선택 중 여부
    let areaSelectionStart = null; // 영역 선택 시작 지점 {x, y}
    let selectionBox = document.getElementById('selection-box'); // 선택 영역 DOM 요소

    // 마커 이미지 설정
    let normalMarkerImage; // 일반 마커 (점 형태)
    let selectedMarkerImage; // 선택된 마커 (점 형태)
    let normalMarkerImagePin; // 일반 마커 핀 형태
    let selectedMarkerImagePin; // 선택된 마커 핀 형태

    // 페이지 초기화
    initializePage();

    // 다중 드래그 중 마커 위치 업데이트 함수
    function updateMultipleDragPositions() {
        if (!isDraggingMultiple || !currentDraggingMarker || !dragStartPosition) {
            return;
        }

        const currentPosition = currentDraggingMarker.getPosition();
        const totalLatDiff = currentPosition.getLat() - dragStartPosition.getLat();
        const totalLngDiff = currentPosition.getLng() - dragStartPosition.getLng();

        // 선택된 다른 마커들도 함께 이동
        selectedCoordinates.forEach(coordId => {
            const initialPosition = selectedMarkersInitialPositions.get(coordId);
            if (initialPosition) {
                const markerInfo = markers.find(m => {
                    const mCoordId = `${m.segmentIndex}_${m.coordIndex}`;
                    return mCoordId === coordId;
                });

                if (markerInfo && markerInfo.marker !== currentDraggingMarker) {
                    const newPos = new kakao.maps.LatLng(
                        initialPosition.getLat() + totalLatDiff,
                        initialPosition.getLng() + totalLngDiff
                    );
                    markerInfo.marker.setPosition(newPos);
                }
            }
        });

        // 다음 프레임에서 다시 실행
        if (isDraggingMultiple) {
            dragAnimationFrameId = requestAnimationFrame(updateMultipleDragPositions);
        }
    }

    // Shift 키 및 ESC 키 이벤트 리스너
    document.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            isShiftPressed = true;
            // Shift 누르면 지도 드래그 비활성화
            if (map) {
                map.setDraggable(false);
            }
        } else if (e.key === 'Escape') {
            const modal = document.getElementById('coordinate-edit-modal');
            if (modal && modal.classList.contains('active')) {
                closeCoordinateModal();
            } else if (selectedCoordinates.size > 0) {
                clearAllSelections();
            }
        }
    });

    document.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            isShiftPressed = false;
            // Shift 떼면 지도 드래그 활성화
            if (map) {
                map.setDraggable(true);
            }
            // 영역 선택 중이었다면 취소
            if (isAreaSelecting) {
                cancelAreaSelection();
            }
        }
    });

    // 영역 선택 시작
    function startAreaSelection(e) {
        if (!isShiftPressed) return;

        const mapContainer = document.getElementById('map');
        const rect = mapContainer.getBoundingClientRect();

        areaSelectionStart = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };

        isAreaSelecting = true;

        // 선택 박스 초기화
        selectionBox.style.left = areaSelectionStart.x + 'px';
        selectionBox.style.top = areaSelectionStart.y + 'px';
        selectionBox.style.width = '0px';
        selectionBox.style.height = '0px';
        selectionBox.style.display = 'block';
    }

    // 영역 선택 업데이트
    function updateAreaSelection(e) {
        if (!isAreaSelecting || !areaSelectionStart) return;

        const mapContainer = document.getElementById('map');
        const rect = mapContainer.getBoundingClientRect();

        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;

        const width = Math.abs(currentX - areaSelectionStart.x);
        const height = Math.abs(currentY - areaSelectionStart.y);
        const left = Math.min(currentX, areaSelectionStart.x);
        const top = Math.min(currentY, areaSelectionStart.y);

        selectionBox.style.left = left + 'px';
        selectionBox.style.top = top + 'px';
        selectionBox.style.width = width + 'px';
        selectionBox.style.height = height + 'px';
    }

    // 영역 선택 완료
    function completeAreaSelection(e) {
        if (!isAreaSelecting || !areaSelectionStart) return;

        const mapContainer = document.getElementById('map');
        const rect = mapContainer.getBoundingClientRect();

        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;

        const selectionRect = {
            left: Math.min(currentX, areaSelectionStart.x),
            top: Math.min(currentY, areaSelectionStart.y),
            right: Math.max(currentX, areaSelectionStart.x),
            bottom: Math.max(currentY, areaSelectionStart.y)
        };

        // 선택 영역 내의 마커 찾기
        const selectedCount = selectMarkersInRect(selectionRect, rect);

        // 선택 박스 숨기기
        selectionBox.style.display = 'none';
        isAreaSelecting = false;
        areaSelectionStart = null;

        if (selectedCount > 0) {
            showMessage(`${selectedCount}개의 좌표가 선택되었습니다.`, 'success');
        }
    }

    // 영역 선택 취소
    function cancelAreaSelection() {
        selectionBox.style.display = 'none';
        isAreaSelecting = false;
        areaSelectionStart = null;
    }

    // 사각형 영역 내의 마커 선택
    function selectMarkersInRect(selectionRect, mapRect) {
        let selectedCount = 0;

        markers.forEach(markerInfo => {
            const marker = markerInfo.marker;
            const position = marker.getPosition();

            // 지도 좌표를 화면 좌표로 변환
            const projection = map.getProjection();
            const point = projection.containerPointFromCoords(position);

            // 선택 영역 내에 있는지 확인
            if (point.x >= selectionRect.left && point.x <= selectionRect.right &&
                point.y >= selectionRect.top && point.y <= selectionRect.bottom) {

                const coordId = `${markerInfo.segmentIndex}_${markerInfo.coordIndex}`;
                const checkbox = document.getElementById(`checkbox-${coordId}`);

                // 이미 선택되어 있지 않다면 선택
                if (checkbox && !checkbox.checked) {
                    checkbox.checked = true;
                    toggleCoordinate(markerInfo.segmentIndex, markerInfo.coordIndex);
                    selectedCount++;
                }
            }
        });

        return selectedCount;
    }

    async function initializePage() {
        // 카카오 맵 초기화
        const mapContainer = document.getElementById('map');
        const mapOption = {
            center: new kakao.maps.LatLng(37.5665, 126.9780),
            level: 1 // 최대 확대 레벨
        };

        map = new kakao.maps.Map(mapContainer, mapOption);

        // 영역 선택을 위한 마우스 이벤트 리스너 추가
        mapContainer.addEventListener('mousedown', startAreaSelection);
        mapContainer.addEventListener('mousemove', updateAreaSelection);
        mapContainer.addEventListener('mouseup', completeAreaSelection);

        // 마커 이미지 초기화
        const dotSize = new kakao.maps.Size(6.76, 6.76); // 점 크기 (30% 증가: 5.2 * 1.3 = 6.76)
        const pinSize = new kakao.maps.Size(20.8, 31.2); // 핀 크기 (30% 증가: 16 * 1.3 = 20.8, 24 * 1.3 = 31.2)

        // 점 형태 마커 (SVG로 작은 원 생성)
        const normalDotSvg = `data:image/svg+xml;base64,${btoa(`
            <svg xmlns="http://www.w3.org/2000/svg" width="6.76" height="6.76">
                <circle cx="3.38" cy="3.38" r="3.38" fill="#4A90E2" stroke="white" stroke-width="0.845"/>
            </svg>
        `)}`;

        const selectedDotSvg = `data:image/svg+xml;base64,${btoa(`
            <svg xmlns="http://www.w3.org/2000/svg" width="6.76" height="6.76">
                <circle cx="3.38" cy="3.38" r="3.38" fill="#FF0000" stroke="white" stroke-width="0.845"/>
            </svg>
        `)}`;

        normalMarkerImage = new kakao.maps.MarkerImage(normalDotSvg, dotSize);
        selectedMarkerImage = new kakao.maps.MarkerImage(selectedDotSvg, dotSize);

        // 핀 형태 마커
        normalMarkerImagePin = new kakao.maps.MarkerImage(
            'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/markerStar.png',
            pinSize
        );
        selectedMarkerImagePin = new kakao.maps.MarkerImage(
            'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/marker_red.png',
            pinSize
        );

        // 코스 정보 로드
        await loadCourse();
    }

    // 메시지 표시
    function showMessage(message, type = 'error') {
        const messageContainer = document.getElementById('message-container');
        const className = type === 'error' ? 'error-message' : 'success-message';
        messageContainer.innerHTML = `<div class="${className}">${message}</div>`;
        setTimeout(() => {
            messageContainer.innerHTML = '';
        }, 5000);
    }

    // 코스 정보 로드
    async function loadCourse() {
        try {
            const response = await axios.get(`/admin/api/courses/${courseId}`, {
                withCredentials: true
            });

            if (response.data) {
                course = response.data;
                originalCourse = JSON.parse(JSON.stringify(course)); // 깊은 복사
                displayCourseInfo();
                displayCoordinatesList();
                drawCourseOnMap();
            } else {
                showMessage('코스를 찾을 수 없습니다.');
            }
        } catch (error) {
            if (error.response && error.response.status === 401) {
                alert('로그인 세션이 만료되었습니다.');
                window.location.href = '/admin/login';
            } else if (error.response && error.response.status === 403) {
                alert('권한이 없습니다. 관리자 로그인이 필요합니다.');
                window.location.href = '/admin/login';
            } else {
                showMessage('코스 정보를 불러오는데 실패했습니다.');
            }
        }
    }

    // 코스 정보 표시
    function displayCourseInfo() {
        try {
            const infoContainer = document.getElementById('course-info');

            const totalCoordinates = course.segments.reduce((sum, segment) =>
                    sum + segment.coordinates.length, 0
            );

            let html = `
                            <div class="course-info">
                                <div class="info-item">
                                    <div class="info-label">코스 이름</div>
                                    <div class="info-value editable">
                                        <input type="text"
                                               id="course-name-input"
                                               class="info-input"
                                               value="${course.name}"
                                               onchange="updateCourseName(this.value)">
                                    </div>
                                </div>
                                <div class="info-item">
                                    <div class="info-label">코스 길이</div>
                                    <div class="info-value">${(course.length / 1000).toFixed(2)} km</div>
                                </div>
                                <div class="info-item">
                                    <div class="info-label">도로 타입</div>
                                    <div class="info-value editable">
                                        <select id="road-type-select"
                                                class="info-select"
                                                onchange="updateRoadType(this.value)">
                                            <option value="트랙" ${course.roadType === '트랙' ? 'selected' : ''}>트랙</option>
                                            <option value="트레일" ${course.roadType === '트레일' ? 'selected' : ''}>트레일</option>
                                            <option value="보도" ${course.roadType === '보도' ? 'selected' : ''}>보도</option>
                                            <option value="알수없음" ${course.roadType === '알수없음' ? 'selected' : ''}>알수없음</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="info-item">
                                    <div class="info-label">난이도</div>
                                    <div class="info-value">${course.difficulty}</div>
                                </div>
                                <div class="info-item">
                                    <div class="info-label">총 좌표 수</div>
                                    <div class="info-value">${totalCoordinates}개</div>
                                </div>
                            </div>
                            <div class="segment-list">
                                <h3 style="margin-bottom: 15px; color: #2d3748;">세그먼트 목록</h3>
                        `;

            course.segments.forEach((segment, index) => {
                html += `
                                <div class="segment-item">
                                    <div class="segment-header">
                                        <span>세그먼트 ${index + 1}</span>
                                        <span class="incline-badge ${segment.inclineType}">${segment.inclineType}</span>
                                    </div>
                                    <div class="coordinate-count">좌표 ${segment.coordinates.length}개</div>
                                </div>
                            `;
            });

            html += '</div>';

            infoContainer.innerHTML = html;
        } catch (error) {
            showMessage('코스 정보 표시 중 오류가 발생했습니다: ' + error.message, 'error');
        }
    }

    // 좌표 목록 표시
    function displayCoordinatesList() {
        try {
            const coordinatesContainer = document.getElementById('coordinates-container');
            coordinatesContainer.style.display = 'block';

            let html = `
                            <div class="coordinates-header">
                                <div class="coordinates-title">전체 좌표 목록</div>
                                <div class="bulk-actions">
                                    <button class="bulk-button secondary" onclick="showSelectedOnMap()" id="show-on-map-btn" disabled>
                                        지도에서 보기
                                    </button>
                                    <button class="bulk-button primary" onclick="bulkEditCoordinates()" id="bulk-edit-btn" disabled>
                                        일괄 수정
                                    </button>
                                    <button class="bulk-button danger" onclick="bulkDeleteCoordinates()" id="bulk-delete-btn" disabled style="background: #e53e3e; color: white;">
                                        일괄 삭제
                                    </button>
                                </div>
                            </div>
                            <table class="coordinates-table">
                                <thead>
                                    <tr>
                                        <th>
                                            <label class="select-all-label">
                                                <input type="checkbox" class="coord-checkbox" id="select-all-checkbox" onchange="toggleAllCoordinates()">
                                                전체 선택
                                            </label>
                                        </th>
                                        <th>번호</th>
                                        <th>세그먼트</th>
                                        <th>위도</th>
                                        <th>경도</th>
                                        <th>고도(m)</th>
                                        <th>편집</th>
                                    </tr>
                                </thead>
                                <tbody>
                        `;

            let coordNumber = 1;
            course.segments.forEach((segment, segIdx) => {
                segment.coordinates.forEach((coord, coordIdx) => {
                    const coordId = `${segIdx}_${coordIdx}`;
                    const lat = (coord.latitude != null && !isNaN(coord.latitude)) ? Number(coord.latitude).toFixed(6) : 'N/A';
                    const lng = (coord.longitude != null && !isNaN(coord.longitude)) ? Number(coord.longitude).toFixed(6) : 'N/A';
                    const elev = (coord.elevation != null && !isNaN(coord.elevation)) ? Number(coord.elevation).toFixed(1) : 'N/A';

                    html += `
                                    <tr id="coord-row-${coordId}" class="${selectedCoordinates.has(coordId) ? 'selected' : ''}">
                                        <td>
                                            <input type="checkbox" class="coord-checkbox"
                                                   id="checkbox-${coordId}"
                                                   ${selectedCoordinates.has(coordId) ? 'checked' : ''}
                                                   onchange="toggleCoordinate(${segIdx}, ${coordIdx})">
                                        </td>
                                        <td class="coord-number">#${coordNumber}</td>
                                        <td>세그먼트 ${segIdx + 1}</td>
                                        <td class="coord-value">${lat}</td>
                                        <td class="coord-value">${lng}</td>
                                        <td class="coord-value">${elev}</td>
                                        <td>
                                            <button class="coord-edit-btn" onclick="editSingleCoordinate(${segIdx}, ${coordIdx})">
                                                수정
                                            </button>
                                        </td>
                                    </tr>
                                `;
                    coordNumber++;
                });
            });

            html += `
                                </tbody>
                            </table>
                        `;

            coordinatesContainer.innerHTML = html;
            updateBulkActionButtons();
        } catch (error) {
            showMessage('좌표 목록 표시 중 오류가 발생했습니다: ' + error.message, 'error');
        }
    }

    // inclineType에 따른 색상 반환
    function getColorByInclineType(inclineType) {
        switch (inclineType) {
            case 'UPHILL':
                return '#FF0000';
            case 'FLAT':
                return '#00FF00';
            case 'DOWNHILL':
                return '#0000FF';
            default:
                return '#808080';
        }
    }

    // 지도에 코스 그리기
    function drawCourseOnMap() {
        try {
            // 기존 마커와 폴리라인 제거
            clearMap();

            if (!course || !course.segments || course.segments.length === 0) {
                return;
            }

            let allCoordinates = [];

            // 각 세그먼트별로 폴리라인 그리기
            course.segments.forEach((segment, segmentIndex) => {

                if (!segment.coordinates || segment.coordinates.length === 0) {
                    return;
                }

                // 좌표 배열을 카카오맵 LatLng 객체로 변환
                const path = segment.coordinates.map(coord => {
                    return new kakao.maps.LatLng(coord.latitude, coord.longitude);
                });

                allCoordinates.push(...path);

                // 폴리라인 생성
                const polyline = new kakao.maps.Polyline({
                    path: path,
                    strokeWeight: 5,
                    strokeColor: getColorByInclineType(segment.inclineType),
                    strokeOpacity: 0.8,
                    strokeStyle: 'solid'
                });

                polyline.setMap(map);
                polylines.push(polyline);

                // 각 좌표에 드래그 가능한 마커 추가
                segment.coordinates.forEach((coord, coordIndex) => {
                    const position = new kakao.maps.LatLng(coord.latitude, coord.longitude);

                    const marker = new kakao.maps.Marker({
                        position: position,
                        draggable: true,
                        map: map,
                        image: normalMarkerImage // 점 형태로 시작
                    });

                    // 마커 클릭 이벤트 (Shift + 클릭으로 다중 선택)
                    kakao.maps.event.addListener(marker, 'click', function () {
                        const coordId = `${segmentIndex}_${coordIndex}`;
                        const checkbox = document.getElementById(`checkbox-${coordId}`);

                        if (isShiftPressed) {
                            // Shift 누른 상태: 토글 (기존 선택 유지)
                            if (checkbox) {
                                checkbox.checked = !checkbox.checked;
                                toggleCoordinate(segmentIndex, coordIndex);
                            }
                        } else {
                            // Shift 안 누른 상태: 기존 선택 모두 해제 후 현재 마커만 선택
                            clearAllSelections();
                            if (checkbox) {
                                checkbox.checked = true;
                                toggleCoordinate(segmentIndex, coordIndex);
                            }
                        }
                    });

                    // 마커 마우스오버 이벤트 (점 → 핀)
                    kakao.maps.event.addListener(marker, 'mouseover', function () {
                        const coordId = `${segmentIndex}_${coordIndex}`;
                        const isSelected = selectedCoordinates.has(coordId);
                        const pinImage = isSelected ? selectedMarkerImagePin : normalMarkerImagePin;
                        marker.setImage(pinImage);
                        marker.setZIndex(2000); // 가장 위에 표시
                    });

                    // 마커 마우스아웃 이벤트 (핀 → 점)
                    kakao.maps.event.addListener(marker, 'mouseout', function () {
                        const coordId = `${segmentIndex}_${coordIndex}`;
                        const isSelected = selectedCoordinates.has(coordId);
                        const dotImage = isSelected ? selectedMarkerImage : normalMarkerImage;
                        marker.setImage(dotImage);
                        marker.setZIndex(isSelected ? 1000 : 1);
                    });

                    // 마커 드래그 시작 이벤트
                    kakao.maps.event.addListener(marker, 'dragstart', function () {
                        const coordId = `${segmentIndex}_${coordIndex}`;
                        const isSelected = selectedCoordinates.has(coordId);

                        // 드래그 시작 시 핀 형태로 변경
                        const pinImage = isSelected ? selectedMarkerImagePin : normalMarkerImagePin;
                        marker.setImage(pinImage);

                        if (selectedCoordinates.has(coordId) && selectedCoordinates.size > 1) {
                            // 선택된 마커를 드래그하는 경우 다중 드래그 모드
                            isDraggingMultiple = true;
                            currentDraggingMarker = marker;
                            const startPos = marker.getPosition();
                            // 위치 복사 (참조가 아닌 새로운 객체 생성)
                            dragStartPosition = new kakao.maps.LatLng(startPos.getLat(), startPos.getLng());

                            // 모든 선택된 마커의 초기 위치 저장
                            selectedMarkersInitialPositions.clear();
                            selectedCoordinates.forEach(selectedCoordId => {
                                const [segIdx, coordIdx] = selectedCoordId.split('_').map(Number);
                                const markerInfo = markers.find(m =>
                                    m.segmentIndex === segIdx && m.coordIndex === coordIdx
                                );
                                if (markerInfo) {
                                    const pos = markerInfo.marker.getPosition();
                                    // 위치 복사 (참조가 아닌 새로운 객체 생성)
                                    selectedMarkersInitialPositions.set(
                                        selectedCoordId,
                                        new kakao.maps.LatLng(pos.getLat(), pos.getLng())
                                    );

                                    // 선택된 다른 마커들도 핀 형태로 변경
                                    markerInfo.marker.setImage(selectedMarkerImagePin);
                                }
                            });

                            // 드래그 업데이트 시작
                            dragAnimationFrameId = requestAnimationFrame(updateMultipleDragPositions);
                        } else {
                            isDraggingMultiple = false;
                            currentDraggingMarker = null;
                            selectedMarkersInitialPositions.clear();
                        }
                    });


                    // 마커 드래그 종료 이벤트
                    kakao.maps.event.addListener(marker, 'dragend', function () {
                        // 애니메이션 프레임 취소
                        if (dragAnimationFrameId) {
                            cancelAnimationFrame(dragAnimationFrameId);
                            dragAnimationFrameId = null;
                        }

                        const newPosition = marker.getPosition();
                        const coordId = `${segmentIndex}_${coordIndex}`;
                        const isSelected = selectedCoordinates.has(coordId);

                        if (isDraggingMultiple) {
                            // 다중 드래그인 경우 모든 선택된 좌표 업데이트
                            onMultipleMarkersDragEnd();

                            // 모든 선택된 마커를 점 형태로 복원
                            selectedCoordinates.forEach(selectedCoordId => {
                                const markerInfo = markers.find(m => {
                                    const mCoordId = `${m.segmentIndex}_${m.coordIndex}`;
                                    return mCoordId === selectedCoordId;
                                });
                                if (markerInfo) {
                                    markerInfo.marker.setImage(selectedMarkerImage);
                                }
                            });
                        } else {
                            // 단일 마커 드래그
                            onMarkerDragEnd(segmentIndex, coordIndex, newPosition);
                            // 점 형태로 복원
                            const dotImage = isSelected ? selectedMarkerImage : normalMarkerImage;
                            marker.setImage(dotImage);
                        }
                        // 상태 초기화
                        isDraggingMultiple = false;
                        currentDraggingMarker = null;
                        dragStartPosition = null;
                        selectedMarkersInitialPositions.clear();
                    });

                    // 마커 오른쪽 클릭 이벤트
                    kakao.maps.event.addListener(marker, 'rightclick', function () {
                        openCoordinateModal(segmentIndex, coordIndex);
                    });

                    markers.push({
                        marker: marker,
                        segmentIndex: segmentIndex,
                        coordIndex: coordIndex
                    });
                });
            });

            // 지도 중심을 코스에 맞추기 (초기 로드 시에만)
            if (isInitialLoad && allCoordinates.length > 0) {
                const bounds = new kakao.maps.LatLngBounds();
                allCoordinates.forEach(coord => bounds.extend(coord));
                map.setBounds(bounds);
                isInitialLoad = false;
            }
        } catch (error) {
            showMessage('지도에 코스를 그리는 중 오류가 발생했습니다: ' + error.message, 'error');
        }
    }

    // 다중 마커 드래그 종료 시 처리
    function onMultipleMarkersDragEnd() {
        const affectedSegments = new Set();

        // 모든 선택된 마커의 현재 위치를 좌표 데이터에 반영
        selectedCoordinates.forEach(coordId => {
            const [segIdx, coordIdx] = coordId.split('_').map(Number);
            const markerInfo = markers.find(m =>
                m.segmentIndex === segIdx && m.coordIndex === coordIdx
            );

            if (markerInfo) {
                const currentPos = markerInfo.marker.getPosition();
                const segment = course.segments[segIdx];
                const isFirstCoord = coordIdx === 0;
                const isLastCoord = coordIdx === segment.coordinates.length - 1;

                // 좌표 데이터 업데이트
                segment.coordinates[coordIdx].latitude = currentPos.getLat();
                segment.coordinates[coordIdx].longitude = currentPos.getLng();
                affectedSegments.add(segIdx);

                // 세그먼트 경계 좌표인 경우 인접 세그먼트도 업데이트
                if (isFirstCoord && segIdx > 0) {
                    const prevSegment = course.segments[segIdx - 1];
                    const prevLastIndex = prevSegment.coordinates.length - 1;
                    prevSegment.coordinates[prevLastIndex].latitude = currentPos.getLat();
                    prevSegment.coordinates[prevLastIndex].longitude = currentPos.getLng();
                    affectedSegments.add(segIdx - 1);

                    // 이전 세그먼트의 마지막 마커도 업데이트 (선택되지 않은 경우)
                    const prevCoordId = `${segIdx - 1}_${prevLastIndex}`;
                    if (!selectedCoordinates.has(prevCoordId)) {
                        const prevMarkerInfo = markers.find(m =>
                            m.segmentIndex === segIdx - 1 && m.coordIndex === prevLastIndex
                        );
                        if (prevMarkerInfo) {
                            prevMarkerInfo.marker.setPosition(currentPos);
                        }
                    }
                }

                if (isLastCoord && segIdx < course.segments.length - 1) {
                    const nextSegment = course.segments[segIdx + 1];
                    nextSegment.coordinates[0].latitude = currentPos.getLat();
                    nextSegment.coordinates[0].longitude = currentPos.getLng();
                    affectedSegments.add(segIdx + 1);

                    // 다음 세그먼트의 첫 번째 마커도 업데이트 (선택되지 않은 경우)
                    const nextCoordId = `${segIdx + 1}_0`;
                    if (!selectedCoordinates.has(nextCoordId)) {
                        const nextMarkerInfo = markers.find(m =>
                            m.segmentIndex === segIdx + 1 && m.coordIndex === 0
                        );
                        if (nextMarkerInfo) {
                            nextMarkerInfo.marker.setPosition(currentPos);
                        }
                    }
                }
            }
        });

        // 영향받은 세그먼트의 폴리라인 업데이트
        updateSegmentPolylines(Array.from(affectedSegments));

        // 좌표 목록 UI 업데이트
        displayCoordinatesList();

        showMessage(`${selectedCoordinates.size}개의 좌표가 함께 이동되었습니다.`, 'success');
    }

    // 마커 드래그 종료 시 처리
    function onMarkerDragEnd(segmentIndex, coordIndex, newPosition) {
        const segment = course.segments[segmentIndex];
        const isFirstCoord = coordIndex === 0;
        const isLastCoord = coordIndex === segment.coordinates.length - 1;

        // 현재 좌표 업데이트
        segment.coordinates[coordIndex].latitude = newPosition.getLat();
        segment.coordinates[coordIndex].longitude = newPosition.getLng();

        // 업데이트할 세그먼트 인덱스 수집
        const segmentsToUpdate = [segmentIndex];
        const markersToUpdate = [];

        // 세그먼트 경계 좌표인 경우 인접 세그먼트와 마커도 업데이트
        if (isFirstCoord && segmentIndex > 0) {
            // 첫 번째 좌표이고 이전 세그먼트가 있는 경우
            const prevSegment = course.segments[segmentIndex - 1];
            const prevLastIndex = prevSegment.coordinates.length - 1;
            prevSegment.coordinates[prevLastIndex].latitude = newPosition.getLat();
            prevSegment.coordinates[prevLastIndex].longitude = newPosition.getLng();
            segmentsToUpdate.push(segmentIndex - 1);

            // 이전 세그먼트의 마지막 마커 찾아서 위치 업데이트
            const prevMarkerInfo = markers.find(m =>
                    m.segmentIndex === segmentIndex - 1 &&
                    m.coordIndex === prevLastIndex
            );
            if (prevMarkerInfo) {
                prevMarkerInfo.marker.setPosition(newPosition);
            }
        }

        if (isLastCoord && segmentIndex < course.segments.length - 1) {
            // 마지막 좌표이고 다음 세그먼트가 있는 경우
            const nextSegment = course.segments[segmentIndex + 1];
            nextSegment.coordinates[0].latitude = newPosition.getLat();
            nextSegment.coordinates[0].longitude = newPosition.getLng();
            segmentsToUpdate.push(segmentIndex + 1);

            // 다음 세그먼트의 첫 번째 마커 찾아서 위치 업데이트
            const nextMarkerInfo = markers.find(m =>
                    m.segmentIndex === segmentIndex + 1 &&
                    m.coordIndex === 0
            );
            if (nextMarkerInfo) {
                nextMarkerInfo.marker.setPosition(newPosition);
            }
        }

        // 영향받은 세그먼트의 폴리라인만 업데이트
        updateSegmentPolylines(segmentsToUpdate);

        // 변경 알림
        let message = '좌표가 변경되었습니다.';
        if (isFirstCoord && segmentIndex > 0) {
            message += ' (이전 세그먼트와 연결됨)';
        } else if (isLastCoord && segmentIndex < course.segments.length - 1) {
            message += ' (다음 세그먼트와 연결됨)';
        }
        message += ' (자동 저장 기능은 추후 구현 예정)';
        showMessage(message, 'success');
    }

    // 특정 세그먼트들의 폴리라인만 업데이트
    function updateSegmentPolylines(segmentIndices) {
        segmentIndices.forEach(segmentIndex => {
            const segment = course.segments[segmentIndex];
            if (!segment || !segment.coordinates || segment.coordinates.length === 0) {
                return;
            }

            // 기존 폴리라인 제거 (해당 세그먼트만)
            const oldPolyline = polylines[segmentIndex];
            if (oldPolyline) {
                oldPolyline.setMap(null);
            }

            // 새 경로로 폴리라인 생성
            const path = segment.coordinates.map(coord =>
                    new kakao.maps.LatLng(coord.latitude, coord.longitude)
            );

            const newPolyline = new kakao.maps.Polyline({
                path: path,
                strokeWeight: 5,
                strokeColor: getColorByInclineType(segment.inclineType),
                strokeOpacity: 0.8,
                strokeStyle: 'solid'
            });

            newPolyline.setMap(map);
            polylines[segmentIndex] = newPolyline;
        });
    }

    // 모든 폴리라인 업데이트
    function updatePolylines() {
        // 기존 폴리라인 제거
        polylines.forEach(polyline => polyline.setMap(null));
        polylines = [];

        // 폴리라인 다시 그리기
        course.segments.forEach(segment => {
            if (!segment.coordinates || segment.coordinates.length === 0) {
                return;
            }

            const path = segment.coordinates.map(coord =>
                    new kakao.maps.LatLng(coord.latitude, coord.longitude)
            );

            const polyline = new kakao.maps.Polyline({
                path: path,
                strokeWeight: 5,
                strokeColor: getColorByInclineType(segment.inclineType),
                strokeOpacity: 0.8,
                strokeStyle: 'solid'
            });

            polyline.setMap(map);
            polylines.push(polyline);
        });
    }

    // 지도 초기화
    function clearMap() {
        markers.forEach(item => item.marker.setMap(null));
        markers = [];
        polylines.forEach(polyline => polyline.setMap(null));
        polylines = [];
    }

    // 변경사항 초기화
    function resetChanges() {
        if (confirm('모든 변경사항을 초기화하시겠습니까?')) {
            course = JSON.parse(JSON.stringify(originalCourse));
            displayCourseInfo();
            displayCoordinatesList();
            drawCourseOnMap();
            showMessage('변경사항이 초기화되었습니다.', 'success');
        }
    }

    // 모든 선택 해제
    function clearAllSelections() {
        // 선택된 모든 좌표를 배열로 복사 (Set을 순회하면서 삭제하면 문제가 생김)
        const selectedArray = Array.from(selectedCoordinates);

        selectedArray.forEach(coordId => {
            const [segIdx, coordIdx] = coordId.split('_').map(Number);
            const row = document.getElementById(`coord-row-${coordId}`);
            const checkbox = document.getElementById(`checkbox-${coordId}`);

            if (checkbox) {
                checkbox.checked = false;
            }
            if (row) {
                row.classList.remove('selected');
            }

            // 마커 찾기
            const markerInfo = markers.find(m =>
                m.segmentIndex === segIdx && m.coordIndex === coordIdx
            );

            // 마커 이미지를 기본 이미지로 변경
            if (markerInfo && normalMarkerImage) {
                markerInfo.marker.setImage(normalMarkerImage);
                markerInfo.marker.setZIndex(1);
            }
        });

        // 선택 상태 초기화
        selectedCoordinates.clear();
        updateBulkActionButtons();
        updateSelectAllCheckbox();
    }

    // 좌표 선택/해제
    function toggleCoordinate(segIdx, coordIdx) {
        const coordId = `${segIdx}_${coordIdx}`;
        const row = document.getElementById(`coord-row-${coordId}`);
        const checkbox = document.getElementById(`checkbox-${coordId}`);

        // 마커 찾기
        const markerInfo = markers.find(m =>
                m.segmentIndex === segIdx && m.coordIndex === coordIdx
        );

        if (checkbox.checked) {
            selectedCoordinates.add(coordId);
            row.classList.add('selected');
            // 마커 이미지를 선택 이미지로 변경
            if (markerInfo && selectedMarkerImage) {
                markerInfo.marker.setImage(selectedMarkerImage);
                markerInfo.marker.setZIndex(1000);
            }
        } else {
            selectedCoordinates.delete(coordId);
            row.classList.remove('selected');
            // 마커 이미지를 기본 이미지로 변경
            if (markerInfo) {
                if (normalMarkerImage) {
                    markerInfo.marker.setImage(normalMarkerImage);
                } else {
                    // normalMarkerImage가 null이면 기본 마커로 복원
                    markerInfo.marker.setImage(null);
                }
                markerInfo.marker.setZIndex(1);
            }
        }

        updateBulkActionButtons();
        updateSelectAllCheckbox();
    }

    // 전체 선택/해제
    function toggleAllCoordinates() {
        const selectAllCheckbox = document.getElementById('select-all-checkbox');
        const isChecked = selectAllCheckbox.checked;

        course.segments.forEach((segment, segIdx) => {
            segment.coordinates.forEach((coord, coordIdx) => {
                const coordId = `${segIdx}_${coordIdx}`;
                const row = document.getElementById(`coord-row-${coordId}`);
                const checkbox = document.getElementById(`checkbox-${coordId}`);

                // 마커 찾기
                const markerInfo = markers.find(m =>
                        m.segmentIndex === segIdx && m.coordIndex === coordIdx
                );

                if (checkbox) {
                    checkbox.checked = isChecked;
                    if (isChecked) {
                        selectedCoordinates.add(coordId);
                        row.classList.add('selected');
                        // 마커 이미지를 선택 이미지로 변경
                        if (markerInfo && selectedMarkerImage) {
                            markerInfo.marker.setImage(selectedMarkerImage);
                            markerInfo.marker.setZIndex(1000);
                        }
                    } else {
                        selectedCoordinates.delete(coordId);
                        row.classList.remove('selected');
                        // 마커 이미지를 기본 이미지로 변경
                        if (markerInfo) {
                            if (normalMarkerImage) {
                                markerInfo.marker.setImage(normalMarkerImage);
                            } else {
                                // normalMarkerImage가 null이면 기본 마커로 복원
                                markerInfo.marker.setImage(null);
                            }
                            markerInfo.marker.setZIndex(1);
                        }
                    }
                }
            });
        });

        updateBulkActionButtons();
    }

    // 전체 선택 체크박스 상태 업데이트
    function updateSelectAllCheckbox() {
        const selectAllCheckbox = document.getElementById('select-all-checkbox');
        if (!selectAllCheckbox) return;

        const totalCoordinates = course.segments.reduce((sum, segment) =>
                sum + segment.coordinates.length, 0
        );

        if (selectedCoordinates.size === 0) {
            selectAllCheckbox.checked = false;
            selectAllCheckbox.indeterminate = false;
        } else if (selectedCoordinates.size === totalCoordinates) {
            selectAllCheckbox.checked = true;
            selectAllCheckbox.indeterminate = false;
        } else {
            selectAllCheckbox.checked = false;
            selectAllCheckbox.indeterminate = true;
        }
    }

    // 일괄 수정 버튼 상태 업데이트
    function updateBulkActionButtons() {
        const showOnMapBtn = document.getElementById('show-on-map-btn');
        const bulkEditBtn = document.getElementById('bulk-edit-btn');
        const bulkDeleteBtn = document.getElementById('bulk-delete-btn');
        const clearSelectionBtn = document.getElementById('clear-selection-btn');

        const hasSelection = selectedCoordinates.size > 0;

        if (showOnMapBtn) {
            showOnMapBtn.disabled = !hasSelection;
        }
        if (bulkEditBtn) {
            bulkEditBtn.disabled = !hasSelection;
        }
        if (bulkDeleteBtn) {
            bulkDeleteBtn.disabled = !hasSelection;
        }
        if (clearSelectionBtn) {
            if (hasSelection) {
                clearSelectionBtn.classList.add('visible');
            } else {
                clearSelectionBtn.classList.remove('visible');
            }
        }
    }

    // 선택된 좌표 지도에 표시
    function showSelectedOnMap() {
        if (selectedCoordinates.size === 0) {
            showMessage('선택된 좌표가 없습니다.', 'error');
            return;
        }

        // 모든 마커의 zIndex를 기본값으로 설정
        markers.forEach(item => {
            item.marker.setZIndex(1);
        });

        // 선택된 좌표의 마커만 강조
        const selectedBounds = new kakao.maps.LatLngBounds();
        let selectedCount = 0;

        selectedCoordinates.forEach(coordId => {
            const [segIdx, coordIdx] = coordId.split('_').map(Number);
            const markerInfo = markers.find(m =>
                    m.segmentIndex === segIdx && m.coordIndex === coordIdx
            );

            if (markerInfo) {
                markerInfo.marker.setZIndex(1000);
                const position = markerInfo.marker.getPosition();
                selectedBounds.extend(position);
                selectedCount++;
            }
        });

        if (selectedCount > 0) {
            map.setBounds(selectedBounds);
            showMessage(`${selectedCount}개의 선택된 좌표가 강조되었습니다.`, 'success');
        }
    }

    // 단일 좌표 수정
    function editSingleCoordinate(segIdx, coordIdx) {
        const coord = course.segments[segIdx].coordinates[coordIdx];

        const latitude = prompt('위도를 입력하세요:', coord.latitude.toFixed(6));
        if (latitude === null) return;

        const longitude = prompt('경도를 입력하세요:', coord.longitude.toFixed(6));
        if (longitude === null) return;

        const elevation = prompt('고도(m)를 입력하세요:', coord.elevation.toFixed(1));
        if (elevation === null) return;

        const newLat = parseFloat(latitude);
        const newLng = parseFloat(longitude);
        const newElev = parseFloat(elevation);

        // 유효성 검사
        if (isNaN(newLat) || isNaN(newLng) || isNaN(newElev)) {
            showMessage('잘못된 입력입니다. 숫자를 입력해주세요.', 'error');
            return;
        }

        if (newLat < -90 || newLat > 90) {
            showMessage('위도는 -90 ~ 90 사이의 값이어야 합니다.', 'error');
            return;
        }

        if (newLng < -180 || newLng > 180) {
            showMessage('경도는 -180 ~ 180 사이의 값이어야 합니다.', 'error');
            return;
        }

        // 좌표 업데이트
        coord.latitude = newLat;
        coord.longitude = newLng;
        coord.elevation = newElev;

        // 세그먼트 경계 좌표인 경우 인접 세그먼트도 업데이트
        const segment = course.segments[segIdx];
        const isFirstCoord = coordIdx === 0;
        const isLastCoord = coordIdx === segment.coordinates.length - 1;
        const segmentsToUpdate = [segIdx];

        if (isFirstCoord && segIdx > 0) {
            const prevSegment = course.segments[segIdx - 1];
            const prevLastIndex = prevSegment.coordinates.length - 1;
            prevSegment.coordinates[prevLastIndex].latitude = newLat;
            prevSegment.coordinates[prevLastIndex].longitude = newLng;
            prevSegment.coordinates[prevLastIndex].elevation = newElev;
            segmentsToUpdate.push(segIdx - 1);
        }

        if (isLastCoord && segIdx < course.segments.length - 1) {
            const nextSegment = course.segments[segIdx + 1];
            nextSegment.coordinates[0].latitude = newLat;
            nextSegment.coordinates[0].longitude = newLng;
            nextSegment.coordinates[0].elevation = newElev;
            segmentsToUpdate.push(segIdx + 1);
        }

        // 지도의 마커 위치 업데이트
        const newPosition = new kakao.maps.LatLng(newLat, newLng);
        const markerInfo = markers.find(m =>
                m.segmentIndex === segIdx && m.coordIndex === coordIdx
        );
        if (markerInfo) {
            markerInfo.marker.setPosition(newPosition);
        }

        // 인접 마커들도 업데이트
        if (isFirstCoord && segIdx > 0) {
            const prevSegment = course.segments[segIdx - 1];
            const prevLastIndex = prevSegment.coordinates.length - 1;
            const prevMarkerInfo = markers.find(m =>
                    m.segmentIndex === segIdx - 1 && m.coordIndex === prevLastIndex
            );
            if (prevMarkerInfo) {
                prevMarkerInfo.marker.setPosition(newPosition);
            }
        }

        if (isLastCoord && segIdx < course.segments.length - 1) {
            const nextMarkerInfo = markers.find(m =>
                    m.segmentIndex === segIdx + 1 && m.coordIndex === 0
            );
            if (nextMarkerInfo) {
                nextMarkerInfo.marker.setPosition(newPosition);
            }
        }

        // 폴리라인 업데이트
        updateSegmentPolylines(segmentsToUpdate);

        // UI 업데이트
        displayCoordinatesList();
        showMessage('좌표가 수정되었습니다.', 'success');
    }

    // 일괄 수정
    function bulkEditCoordinates() {
        if (selectedCoordinates.size === 0) {
            showMessage('선택된 좌표가 없습니다.', 'error');
            return;
        }

        const elevationOffset = prompt(`${selectedCoordinates.size}개의 선택된 좌표의 고도를 일괄 수정합니다.\n고도 변경값(m)을 입력하세요 (예: +10, -5):`, '+0');
        if (elevationOffset === null) return;

        const offset = parseFloat(elevationOffset);
        if (isNaN(offset)) {
            showMessage('잘못된 입력입니다. 숫자를 입력해주세요.', 'error');
            return;
        }

        // 선택된 좌표들의 고도 일괄 수정
        const updatedSegments = new Set();
        selectedCoordinates.forEach(coordId => {
            const [segIdx, coordIdx] = coordId.split('_').map(Number);
            const coord = course.segments[segIdx].coordinates[coordIdx];
            coord.elevation += offset;
            updatedSegments.add(segIdx);

            // 세그먼트 경계 좌표인 경우 인접 세그먼트도 체크
            const segment = course.segments[segIdx];
            const isFirstCoord = coordIdx === 0;
            const isLastCoord = coordIdx === segment.coordinates.length - 1;

            if (isFirstCoord && segIdx > 0) {
                const prevSegment = course.segments[segIdx - 1];
                const prevLastIndex = prevSegment.coordinates.length - 1;
                prevSegment.coordinates[prevLastIndex].elevation = coord.elevation;
                updatedSegments.add(segIdx - 1);
            }

            if (isLastCoord && segIdx < course.segments.length - 1) {
                const nextSegment = course.segments[segIdx + 1];
                nextSegment.coordinates[0].elevation = coord.elevation;
                updatedSegments.add(segIdx + 1);
            }
        });

        // UI 업데이트
        displayCoordinatesList();
        showMessage(`${selectedCoordinates.size}개 좌표의 고도가 ${offset > 0 ? '+' : ''}${offset}m 변경되었습니다.`, 'success');
    }

    // 일괄 삭제
    function bulkDeleteCoordinates() {
        if (selectedCoordinates.size === 0) {
            showMessage('선택된 좌표가 없습니다.', 'error');
            return;
        }

        // 전체 좌표 수 계산
        const totalCoordinates = course.segments.reduce((sum, segment) =>
                sum + segment.coordinates.length, 0
        );

        // 삭제 후 남을 좌표 수 확인
        const remainingCoordinates = totalCoordinates - selectedCoordinates.size;
        if (remainingCoordinates < 2) {
            showMessage(`코스는 최소 2개 이상의 좌표가 필요합니다. (현재: ${totalCoordinates}개, 선택: ${selectedCoordinates.size}개)`, 'error');
            return;
        }

        if (!confirm(`정말로 선택한 ${selectedCoordinates.size}개의 좌표를 삭제하시겠습니까?`)) {
            return;
        }

        // 삭제할 좌표를 세그먼트별로 그룹화 (역순으로 정렬하여 인덱스 변경 문제 방지)
        const coordsToDelete = Array.from(selectedCoordinates).map(coordId => {
            const [segIdx, coordIdx] = coordId.split('_').map(Number);
            return {segIdx, coordIdx};
        }).sort((a, b) => {
            // 세그먼트 인덱스 역순, 같은 세그먼트 내에서는 좌표 인덱스 역순
            if (a.segIdx !== b.segIdx) {
                return b.segIdx - a.segIdx;
            }
            return b.coordIdx - a.coordIdx;
        });

        // 삭제할 좌표를 Set으로 변환 (빠른 검색을 위해)
        const coordsToDeleteSet = new Set(selectedCoordinates);

        // 역순으로 삭제 (인덱스 변경 문제 방지)
        coordsToDelete.forEach(({segIdx, coordIdx}) => {
            const segment = course.segments[segIdx];
            if (!segment || !segment.coordinates[coordIdx]) {
                return; // 이미 삭제된 경우 스킵
            }

            const coordToDelete = segment.coordinates[coordIdx];
            const isFirstCoord = coordIdx === 0;
            const isLastCoord = coordIdx === segment.coordinates.length - 1;

            // 세그먼트 경계 좌표인 경우 인접 세그먼트에서도 삭제
            if (isFirstCoord && segIdx > 0) {
                const prevSegment = course.segments[segIdx - 1];
                const prevLastIdx = prevSegment.coordinates.length - 1;
                const prevCoordId = `${segIdx - 1}_${prevLastIdx}`;

                // 대응하는 경계 좌표가 삭제 목록에 없을 때만 삭제
                if (prevSegment && prevSegment.coordinates.length > 0 && !coordsToDeleteSet.has(prevCoordId)) {
                    // 실제로 같은 좌표인지 확인 (lat, lng 비교)
                    const prevLastCoord = prevSegment.coordinates[prevLastIdx];
                    if (prevLastCoord.latitude === coordToDelete.latitude &&
                        prevLastCoord.longitude === coordToDelete.longitude) {
                        prevSegment.coordinates.pop(); // 마지막 좌표 제거
                    }
                }
            }

            if (isLastCoord && segIdx < course.segments.length - 1) {
                const nextCoordId = `${segIdx + 1}_0`;

                // 대응하는 경계 좌표가 삭제 목록에 없을 때만 삭제
                const nextSegment = course.segments[segIdx + 1];
                if (nextSegment && nextSegment.coordinates.length > 0 && !coordsToDeleteSet.has(nextCoordId)) {
                    // 실제로 같은 좌표인지 확인 (lat, lng 비교)
                    const nextFirstCoord = nextSegment.coordinates[0];
                    if (nextFirstCoord.latitude === coordToDelete.latitude &&
                        nextFirstCoord.longitude === coordToDelete.longitude) {
                        nextSegment.coordinates.shift(); // 첫 번째 좌표 제거
                    }
                }
            }

            // 현재 세그먼트에서 좌표 삭제
            segment.coordinates.splice(coordIdx, 1);
        });

        // 빈 세그먼트 제거 (역순으로)
        for (let i = course.segments.length - 1; i >= 0; i--) {
            if (course.segments[i].coordinates.length === 0) {
                course.segments.splice(i, 1);
            }
        }

        // 선택된 좌표 초기화
        selectedCoordinates.clear();

        // 지도 다시 그리기
        drawCourseOnMap();

        // UI 업데이트
        displayCourseInfo();
        displayCoordinatesList();
        showMessage(`${coordsToDelete.length}개의 좌표가 삭제되었습니다.`, 'success');
    }

    // 코스 이름 업데이트
    function updateCourseName(newName) {
        if (!course) {
            showMessage('코스 정보를 찾을 수 없습니다.', 'error');
            return;
        }

        // 빈 문자열 체크
        if (!newName.trim()) {
            showMessage('코스 이름을 입력해주세요.', 'error');
            // 이전 값으로 복원
            const nameInput = document.getElementById('course-name-input');
            if (nameInput) {
                nameInput.value = course.name;
            }
            return;
        }

        // 코스 이름 업데이트
        course.name = newName.trim();
        showMessage('코스 이름이 변경되었습니다.', 'success');
    }

    // 도로 타입 업데이트
    function updateRoadType(newRoadType) {
        if (!course) {
            showMessage('코스 정보를 찾을 수 없습니다.', 'error');
            return;
        }

        // 유효한 도로 타입인지 확인
        const validRoadTypes = ['트랙', '트레일', '보도', '알수없음'];
        if (!validRoadTypes.includes(newRoadType)) {
            showMessage('유효하지 않은 도로 타입입니다.', 'error');
            // 이전 값으로 복원
            const roadTypeSelect = document.getElementById('road-type-select');
            if (roadTypeSelect) {
                roadTypeSelect.value = course.roadType;
            }
            return;
        }

        // 도로 타입 업데이트
        course.roadType = newRoadType;
        showMessage('도로 타입이 변경되었습니다.', 'success');
    }

    // 코스 저장
    async function saveCourse() {
        if (!course) {
            showMessage('저장할 코스가 없습니다.', 'error');
            return;
        }

        if (!confirm('변경사항을 저장하시겠습니까?')) {
            return;
        }

        // 저장 버튼 비활성화
        const saveButton = document.querySelector('.save-button');
        if (saveButton) {
            saveButton.disabled = true;
            saveButton.textContent = '저장 중...';
        }

        try {
            // 모든 세그먼트의 좌표를 평탄화하여 [[lat, lng, elev], ...] 형식으로 변환
            const coordinates = [];
            course.segments.forEach(segment => {
                segment.coordinates.forEach(coord => {
                    coordinates.push([
                        coord.latitude,
                        coord.longitude,
                        coord.elevation
                    ]);
                });
            });

            // API 요청 데이터 준비
            const requestData = {
                coordinates: coordinates,
                name: course.name,
                roadType: course.roadType
            };

            // API 호출
            const response = await axios.patch(`/admin/api/courses/${courseId}`, requestData, {
                headers: {
                    'Content-Type': 'application/json'
                },
                withCredentials: true
            });

            if (response.status === 200) {
                // 저장 성공 시 originalCourse 업데이트
                originalCourse = JSON.parse(JSON.stringify(course));
                showMessage('코스가 성공적으로 저장되었습니다.', 'success');
            }

        } catch (error) {
            if (error.response && error.response.status === 401) {
                alert('로그인 세션이 만료되었습니다.');
                window.location.href = '/admin/login';
            } else if (error.response && error.response.status === 403) {
                alert('권한이 없습니다. 관리자 로그인이 필요합니다.');
                window.location.href = '/admin/login';
            } else {
                const errorMessage = error.response?.data?.message || error.message || '알 수 없는 오류';
                showMessage('코스 저장에 실패했습니다: ' + errorMessage, 'error');
            }
        } finally {
            // 저장 버튼 활성화
            if (saveButton) {
                saveButton.disabled = false;
                saveButton.textContent = '저장';
            }
        }
    }

    // 좌표 수정 모달 열기
    function openCoordinateModal(segIdx, coordIdx) {
        const coord = course.segments[segIdx].coordinates[coordIdx];

        // 현재 수정 중인 좌표 정보 저장
        currentEditingCoord = {segIdx, coordIdx};

        // 모달 입력 필드에 현재 값 설정
        document.getElementById('modal-latitude').value = coord.latitude.toFixed(6);
        document.getElementById('modal-longitude').value = coord.longitude.toFixed(6);
        document.getElementById('modal-elevation').value = coord.elevation.toFixed(1);

        // 모달 표시
        const modal = document.getElementById('coordinate-edit-modal');
        modal.classList.add('active');

        // 첫 번째 입력 필드에 포커스
        setTimeout(() => {
            document.getElementById('modal-latitude').focus();
        }, 100);
    }

    // 좌표 수정 모달 닫기
    function closeCoordinateModal() {
        const modal = document.getElementById('coordinate-edit-modal');
        modal.classList.remove('active');
        currentEditingCoord = null;
    }

    // 모달에서 좌표 저장
    function saveCoordinateFromModal() {
        if (!currentEditingCoord) {
            showMessage('수정할 좌표 정보가 없습니다.', 'error');
            return;
        }

        const {segIdx, coordIdx} = currentEditingCoord;

        // 입력값 가져오기
        const newLat = parseFloat(document.getElementById('modal-latitude').value);
        const newLng = parseFloat(document.getElementById('modal-longitude').value);
        const newElev = parseFloat(document.getElementById('modal-elevation').value);

        // 유효성 검사
        if (isNaN(newLat) || isNaN(newLng) || isNaN(newElev)) {
            showMessage('잘못된 입력입니다. 숫자를 입력해주세요.', 'error');
            return;
        }

        if (newLat < -90 || newLat > 90) {
            showMessage('위도는 -90 ~ 90 사이의 값이어야 합니다.', 'error');
            return;
        }

        if (newLng < -180 || newLng > 180) {
            showMessage('경도는 -180 ~ 180 사이의 값이어야 합니다.', 'error');
            return;
        }

        // 좌표 업데이트
        const coord = course.segments[segIdx].coordinates[coordIdx];
        coord.latitude = newLat;
        coord.longitude = newLng;
        coord.elevation = newElev;

        // 세그먼트 경계 좌표인 경우 인접 세그먼트도 업데이트
        const segment = course.segments[segIdx];
        const isFirstCoord = coordIdx === 0;
        const isLastCoord = coordIdx === segment.coordinates.length - 1;
        const segmentsToUpdate = [segIdx];

        if (isFirstCoord && segIdx > 0) {
            const prevSegment = course.segments[segIdx - 1];
            const prevLastIndex = prevSegment.coordinates.length - 1;
            prevSegment.coordinates[prevLastIndex].latitude = newLat;
            prevSegment.coordinates[prevLastIndex].longitude = newLng;
            prevSegment.coordinates[prevLastIndex].elevation = newElev;
            segmentsToUpdate.push(segIdx - 1);
        }

        if (isLastCoord && segIdx < course.segments.length - 1) {
            const nextSegment = course.segments[segIdx + 1];
            nextSegment.coordinates[0].latitude = newLat;
            nextSegment.coordinates[0].longitude = newLng;
            nextSegment.coordinates[0].elevation = newElev;
            segmentsToUpdate.push(segIdx + 1);
        }

        // 지도의 마커 위치 업데이트
        const newPosition = new kakao.maps.LatLng(newLat, newLng);
        const markerInfo = markers.find(m =>
                m.segmentIndex === segIdx && m.coordIndex === coordIdx
        );
        if (markerInfo) {
            markerInfo.marker.setPosition(newPosition);
        }

        // 인접 마커들도 업데이트
        if (isFirstCoord && segIdx > 0) {
            const prevSegment = course.segments[segIdx - 1];
            const prevLastIndex = prevSegment.coordinates.length - 1;
            const prevMarkerInfo = markers.find(m =>
                    m.segmentIndex === segIdx - 1 && m.coordIndex === prevLastIndex
            );
            if (prevMarkerInfo) {
                prevMarkerInfo.marker.setPosition(newPosition);
            }
        }

        if (isLastCoord && segIdx < course.segments.length - 1) {
            const nextMarkerInfo = markers.find(m =>
                    m.segmentIndex === segIdx + 1 && m.coordIndex === 0
            );
            if (nextMarkerInfo) {
                nextMarkerInfo.marker.setPosition(newPosition);
            }
        }

        // 폴리라인 업데이트
        updateSegmentPolylines(segmentsToUpdate);

        // UI 업데이트
        displayCoordinatesList();
        showMessage('좌표가 수정되었습니다.', 'success');

        // 모달 닫기
        closeCoordinateModal();
    }

    // 모달에서 좌표 삭제
    function deleteCoordinateFromModal() {
        if (!currentEditingCoord) {
            showMessage('삭제할 좌표 정보가 없습니다.', 'error');
            return;
        }

        const {segIdx, coordIdx} = currentEditingCoord;

        if (!confirm('정말로 이 좌표를 삭제하시겠습니까?')) {
            return;
        }

        // 전체 좌표 수 계산
        const totalCoordinates = course.segments.reduce((sum, segment) =>
                sum + segment.coordinates.length, 0
        );

        // 최소 좌표 수 검증 (최소 2개 필요)
        if (totalCoordinates <= 2) {
            showMessage('코스는 최소 2개 이상의 좌표가 필요합니다.', 'error');
            return;
        }

        // 좌표 삭제
        const segment = course.segments[segIdx];
        const isFirstCoord = coordIdx === 0;
        const isLastCoord = coordIdx === segment.coordinates.length - 1;

        // 세그먼트 경계 좌표인 경우 인접 세그먼트에서도 삭제
        if (isFirstCoord && segIdx > 0) {
            const prevSegment = course.segments[segIdx - 1];
            prevSegment.coordinates.pop(); // 마지막 좌표 제거
        }

        if (isLastCoord && segIdx < course.segments.length - 1) {
            const nextSegment = course.segments[segIdx + 1];
            nextSegment.coordinates.shift(); // 첫 번째 좌표 제거
        }

        // 현재 세그먼트에서 좌표 삭제
        segment.coordinates.splice(coordIdx, 1);

        // 세그먼트가 비어있으면 세그먼트도 제거
        if (segment.coordinates.length === 0) {
            course.segments.splice(segIdx, 1);
        }

        // 선택된 좌표 Set에서 제거
        const coordId = `${segIdx}_${coordIdx}`;
        selectedCoordinates.delete(coordId);

        // 지도 다시 그리기
        drawCourseOnMap();

        // UI 업데이트
        displayCourseInfo();
        displayCoordinatesList();
        showMessage('좌표가 삭제되었습니다.', 'success');

        // 모달 닫기
        closeCoordinateModal();
    }

    // 모달 외부 클릭 시 닫기
    document.getElementById('coordinate-edit-modal').addEventListener('click', function (e) {
        if (e.target === this) {
            closeCoordinateModal();
        }
    });

    // ESC 키로 모달 닫기 (이미 위에서 keydown 이벤트에 통합됨)

    // Enter 키로 모달 저장
    document.getElementById('coordinate-edit-modal').addEventListener('keydown', function (e) {
        if (e.key === 'Enter' && this.classList.contains('active')) {
            e.preventDefault();
            saveCoordinateFromModal();
        }
    });
</script>
</body>
</html>
