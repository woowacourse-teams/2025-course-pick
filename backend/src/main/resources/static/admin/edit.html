<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>코스 편집 - 런세권</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f5f5f5;
        }

        .container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 700;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .back-button, .save-button {
            padding: 10px 20px;
            border: 2px solid white;
            background: transparent;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: white;
            color: #667eea;
        }

        .save-button {
            background: white;
            color: #667eea;
        }

        .save-button:hover {
            background: #f0f0f0;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(255, 255, 255, 0.3);
        }

        .save-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .content {
            display: flex;
            height: 70vh;
            overflow: hidden;
        }

        .map-section {
            flex: 3;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .map-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            max-width: 300px;
        }

        .map-controls h3 {
            margin-bottom: 15px;
            color: #2d3748;
            font-size: 18px;
        }

        .map-controls p {
            font-size: 14px;
            color: #718096;
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .control-button {
            padding: 10px 20px;
            border: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 10px;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.4);
        }

        .control-button:active {
            transform: translateY(0);
        }

        .control-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .control-button.secondary {
            background: #e2e8f0;
            color: #2d3748;
        }

        .control-button.secondary:hover {
            background: #cbd5e0;
        }

        .info-section {
            flex: 1;
            background: white;
            overflow-y: auto;
            border-left: 1px solid #e2e8f0;
            padding: 20px;
        }

        .info-section h2 {
            color: #2d3748;
            font-size: 20px;
            margin-bottom: 20px;
        }

        .course-info {
            margin-bottom: 20px;
        }

        .info-item {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e2e8f0;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-label {
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 14px;
            color: #2d3748;
        }

        .info-value.editable {
            width: 100%;
        }

        .info-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            color: #2d3748;
            transition: all 0.3s ease;
            outline: none;
        }

        .info-input:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .info-select {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            color: #2d3748;
            transition: all 0.3s ease;
            outline: none;
            background-color: white;
            cursor: pointer;
        }

        .info-select:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .info-select:hover {
            border-color: #cbd5e0;
        }

        .segment-list {
            margin-top: 20px;
        }

        .segment-item {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .segment-header {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .incline-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }

        .incline-badge.UPHILL {
            background: #fed7d7;
            color: #c53030;
        }

        .incline-badge.FLAT {
            background: #c6f6d5;
            color: #276749;
        }

        .incline-badge.DOWNHILL {
            background: #bee3f8;
            color: #2c5282;
        }

        .coordinate-count {
            font-size: 12px;
            color: #718096;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #718096;
        }

        .error-message {
            background: #fed7d7;
            color: #c53030;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .success-message {
            background: #c6f6d5;
            color: #276749;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .marker-dragging {
            cursor: move;
        }

        .coordinates-section {
            background: white;
            padding: 30px;
            border-top: 2px solid #e2e8f0;
        }

        .coordinates-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .coordinates-title {
            font-size: 18px;
            font-weight: 700;
            color: #2d3748;
        }

        .bulk-actions {
            display: flex;
            gap: 10px;
        }

        .bulk-button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .bulk-button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .bulk-button.primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        .bulk-button.secondary {
            background: #e2e8f0;
            color: #2d3748;
        }

        .bulk-button.secondary:hover {
            background: #cbd5e0;
        }

        .bulk-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .coordinates-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 13px;
        }

        .coordinates-table thead {
            background: #f7fafc;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .coordinates-table th {
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            color: #4a5568;
            border-bottom: 2px solid #e2e8f0;
        }

        .coordinates-table td {
            padding: 10px 8px;
            border-bottom: 1px solid #e2e8f0;
            color: #2d3748;
        }

        .coordinates-table tr:hover {
            background: #f7fafc;
        }

        .coordinates-table tr.selected {
            background: #e6f0ff;
        }

        .coord-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .coord-number {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #667eea;
            font-weight: 600;
        }

        .coord-value {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
        }

        .coord-edit-btn {
            padding: 4px 12px;
            border: 1px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .coord-edit-btn:hover {
            background: #667eea;
            color: white;
        }

        .segment-group-header {
            background: #edf2f7;
            font-weight: 700;
            color: #2d3748;
        }

        .select-all-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #4a5568;
            cursor: pointer;
        }

        /* 모달 스타일 */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            font-size: 20px;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #718096;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: #e2e8f0;
            color: #2d3748;
        }

        .modal-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .modal-form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .modal-label {
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
        }

        .modal-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            color: #2d3748;
            transition: all 0.3s ease;
            outline: none;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .modal-input:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .modal-button {
            flex: 1;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .modal-button.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .modal-button.secondary {
            background: #e2e8f0;
            color: #2d3748;
        }

        .modal-button.secondary:hover {
            background: #cbd5e0;
        }

        .modal-button.danger {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            color: white;
        }

        .modal-button.danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(229, 62, 62, 0.4);
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>코스 편집</h1>
        <div class="header-buttons">
            <button class="save-button" onclick="saveCourse()">저장</button>
            <button class="back-button" onclick="window.history.back()">← 뒤로 가기</button>
        </div>
    </div>
    <div class="content">
        <div class="map-section">
            <div id="map"></div>
            <div class="map-controls">
                <h3>편집 가이드</h3>
                <p>지도 위의 마커를 드래그하여 코스 좌표를 수정할 수 있습니다.</p>
                <p>변경사항은 자동으로 저장됩니다.</p>
                <button class="control-button secondary" onclick="resetChanges()">변경사항 초기화</button>
            </div>
        </div>
        <div class="info-section">
            <h2>코스 정보</h2>
            <div id="message-container"></div>
            <div class="loading" id="course-info">코스 정보를 불러오는 중...</div>
        </div>
    </div>
    <div class="coordinates-section" id="coordinates-container" style="display: none;">
        <div class="loading">좌표 목록을 불러오는 중...</div>
    </div>
</div>

<!-- 좌표 수정 모달 -->
<div class="modal-overlay" id="coordinate-edit-modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>좌표 수정</span>
            <button class="modal-close" onclick="closeCoordinateModal()">&times;</button>
        </div>
        <div class="modal-form">
            <div class="modal-form-group">
                <label class="modal-label" for="modal-latitude">위도 (Latitude)</label>
                <input class="modal-input" id="modal-latitude" placeholder="예: 37.566535" step="0.000001" type="number">
            </div>
            <div class="modal-form-group">
                <label class="modal-label" for="modal-longitude">경도 (Longitude)</label>
                <input class="modal-input" id="modal-longitude" placeholder="예: 126.978000" step="0.000001"
                       type="number">
            </div>
            <div class="modal-form-group">
                <label class="modal-label" for="modal-elevation">고도 (Elevation, m)</label>
                <input class="modal-input" id="modal-elevation" placeholder="예: 15.5" step="0.1" type="number">
            </div>
            <div class="modal-actions">
                <button class="modal-button danger" onclick="deleteCoordinateFromModal()">삭제</button>
                <button class="modal-button secondary" onclick="closeCoordinateModal()">취소</button>
                <button class="modal-button primary" onclick="saveCoordinateFromModal()">확인</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script src="//dapi.kakao.com/v2/maps/sdk.js?appkey=KAKAO_API_KEY_PLACEHOLDER" type="text/javascript"></script>
<script>
    // URL에서 코스 ID 추출
    const urlParams = new URLSearchParams(window.location.search);
    const courseId = urlParams.get('id');

    if (!courseId) {
        alert('코스 ID가 지정되지 않았습니다.');
        window.history.back();
    }

    let map;
    let course = null;
    let markers = [];
    let polylines = [];
    let originalCourse = null;
    let isInitialLoad = true; // 초기 로드 여부 플래그
    let selectedCoordinates = new Set(); // 선택된 좌표 (seg-idx_coord-idx 형식)
    let currentEditingCoord = null; // 현재 수정 중인 좌표 {segIdx, coordIdx}

    // 마커 이미지 설정
    let normalMarkerImage;
    let selectedMarkerImage;

    // 페이지 초기화
    initializePage();

    async function initializePage() {
        // 카카오 맵 초기화
        const mapContainer = document.getElementById('map');
        const mapOption = {
            center: new kakao.maps.LatLng(37.5665, 126.9780),
            level: 5
        };

        map = new kakao.maps.Map(mapContainer, mapOption);

        // 마커 이미지 초기화
        const imageSize = new kakao.maps.Size(24, 35);
        // normalMarkerImage는 null (카카오맵 기본 마커 사용)
        normalMarkerImage = null;
        // selectedMarkerImage는 빨간색 마커
        selectedMarkerImage = new kakao.maps.MarkerImage(
                'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/marker_red.png',
                imageSize
        );

        // 코스 정보 로드
        await loadCourse();
    }

    // 메시지 표시
    function showMessage(message, type = 'error') {
        const messageContainer = document.getElementById('message-container');
        const className = type === 'error' ? 'error-message' : 'success-message';
        messageContainer.innerHTML = `<div class="${className}">${message}</div>`;
        setTimeout(() => {
            messageContainer.innerHTML = '';
        }, 5000);
    }

    // 코스 정보 로드
    async function loadCourse() {
        try {
            const response = await axios.get(`/admin/courses/${courseId}`, {
                withCredentials: true
            });

            console.log('API Response:', response.data);

            if (response.data) {
                course = response.data;
                console.log('Course loaded:', course);
                console.log('Segments:', course.segments);
                originalCourse = JSON.parse(JSON.stringify(course)); // 깊은 복사
                displayCourseInfo();
                displayCoordinatesList();
                drawCourseOnMap();
            } else {
                showMessage('코스를 찾을 수 없습니다.');
            }
        } catch (error) {
            console.error('코스 로드 실패:', error);
            if (error.response && error.response.status === 401) {
                alert('로그인 세션이 만료되었습니다.');
                window.location.href = '/admin/login';
            } else if (error.response && error.response.status === 403) {
                alert('권한이 없습니다. 관리자 로그인이 필요합니다.');
                window.location.href = '/admin/login';
            } else {
                showMessage('코스 정보를 불러오는데 실패했습니다.');
            }
        }
    }

    // 코스 정보 표시
    function displayCourseInfo() {
        try {
            console.log('displayCourseInfo 시작');
            const infoContainer = document.getElementById('course-info');

            const totalCoordinates = course.segments.reduce((sum, segment) =>
                    sum + segment.coordinates.length, 0
            );

            let html = `
                            <div class="course-info">
                                <div class="info-item">
                                    <div class="info-label">코스 이름</div>
                                    <div class="info-value editable">
                                        <input type="text"
                                               id="course-name-input"
                                               class="info-input"
                                               value="${course.name}"
                                               onchange="updateCourseName(this.value)">
                                    </div>
                                </div>
                                <div class="info-item">
                                    <div class="info-label">코스 길이</div>
                                    <div class="info-value">${(course.length / 1000).toFixed(2)} km</div>
                                </div>
                                <div class="info-item">
                                    <div class="info-label">도로 타입</div>
                                    <div class="info-value editable">
                                        <select id="road-type-select"
                                                class="info-select"
                                                onchange="updateRoadType(this.value)">
                                            <option value="트랙" ${course.roadType === '트랙' ? 'selected' : ''}>트랙</option>
                                            <option value="트레일" ${course.roadType === '트레일' ? 'selected' : ''}>트레일</option>
                                            <option value="보도" ${course.roadType === '보도' ? 'selected' : ''}>보도</option>
                                            <option value="알수없음" ${course.roadType === '알수없음' ? 'selected' : ''}>알수없음</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="info-item">
                                    <div class="info-label">난이도</div>
                                    <div class="info-value">${course.difficulty}</div>
                                </div>
                                <div class="info-item">
                                    <div class="info-label">총 좌표 수</div>
                                    <div class="info-value">${totalCoordinates}개</div>
                                </div>
                            </div>
                            <div class="segment-list">
                                <h3 style="margin-bottom: 15px; color: #2d3748;">세그먼트 목록</h3>
                        `;

            course.segments.forEach((segment, index) => {
                html += `
                                <div class="segment-item">
                                    <div class="segment-header">
                                        <span>세그먼트 ${index + 1}</span>
                                        <span class="incline-badge ${segment.inclineType}">${segment.inclineType}</span>
                                    </div>
                                    <div class="coordinate-count">좌표 ${segment.coordinates.length}개</div>
                                </div>
                            `;
            });

            html += '</div>';

            infoContainer.innerHTML = html;
            console.log('displayCourseInfo 완료');
        } catch (error) {
            console.error('displayCourseInfo 에러:', error);
            console.error('Error stack:', error.stack);
            showMessage('코스 정보 표시 중 오류가 발생했습니다: ' + error.message, 'error');
        }
    }

    // 좌표 목록 표시
    function displayCoordinatesList() {
        try {
            console.log('displayCoordinatesList 시작');
            const coordinatesContainer = document.getElementById('coordinates-container');
            coordinatesContainer.style.display = 'block';

            let html = `
                            <div class="coordinates-header">
                                <div class="coordinates-title">전체 좌표 목록</div>
                                <div class="bulk-actions">
                                    <button class="bulk-button secondary" onclick="showSelectedOnMap()" id="show-on-map-btn" disabled>
                                        지도에서 보기
                                    </button>
                                    <button class="bulk-button primary" onclick="bulkEditCoordinates()" id="bulk-edit-btn" disabled>
                                        일괄 수정
                                    </button>
                                    <button class="bulk-button danger" onclick="bulkDeleteCoordinates()" id="bulk-delete-btn" disabled style="background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%); color: white;">
                                        일괄 삭제
                                    </button>
                                </div>
                            </div>
                            <table class="coordinates-table">
                                <thead>
                                    <tr>
                                        <th>
                                            <label class="select-all-label">
                                                <input type="checkbox" class="coord-checkbox" id="select-all-checkbox" onchange="toggleAllCoordinates()">
                                                전체 선택
                                            </label>
                                        </th>
                                        <th>번호</th>
                                        <th>세그먼트</th>
                                        <th>위도</th>
                                        <th>경도</th>
                                        <th>고도(m)</th>
                                        <th>편집</th>
                                    </tr>
                                </thead>
                                <tbody>
                        `;

            let coordNumber = 1;
            course.segments.forEach((segment, segIdx) => {
                segment.coordinates.forEach((coord, coordIdx) => {
                    const coordId = `${segIdx}_${coordIdx}`;
                    const lat = (coord.latitude != null && !isNaN(coord.latitude)) ? Number(coord.latitude).toFixed(6) : 'N/A';
                    const lng = (coord.longitude != null && !isNaN(coord.longitude)) ? Number(coord.longitude).toFixed(6) : 'N/A';
                    const elev = (coord.elevation != null && !isNaN(coord.elevation)) ? Number(coord.elevation).toFixed(1) : 'N/A';

                    html += `
                                    <tr id="coord-row-${coordId}" class="${selectedCoordinates.has(coordId) ? 'selected' : ''}">
                                        <td>
                                            <input type="checkbox" class="coord-checkbox"
                                                   id="checkbox-${coordId}"
                                                   ${selectedCoordinates.has(coordId) ? 'checked' : ''}
                                                   onchange="toggleCoordinate(${segIdx}, ${coordIdx})">
                                        </td>
                                        <td class="coord-number">#${coordNumber}</td>
                                        <td>세그먼트 ${segIdx + 1}</td>
                                        <td class="coord-value">${lat}</td>
                                        <td class="coord-value">${lng}</td>
                                        <td class="coord-value">${elev}</td>
                                        <td>
                                            <button class="coord-edit-btn" onclick="editSingleCoordinate(${segIdx}, ${coordIdx})">
                                                수정
                                            </button>
                                        </td>
                                    </tr>
                                `;
                    coordNumber++;
                });
            });

            html += `
                                </tbody>
                            </table>
                        `;

            coordinatesContainer.innerHTML = html;
            updateBulkActionButtons();
            console.log('displayCoordinatesList 완료');
        } catch (error) {
            console.error('displayCoordinatesList 에러:', error);
            console.error('Error stack:', error.stack);
            showMessage('좌표 목록 표시 중 오류가 발생했습니다: ' + error.message, 'error');
        }
    }

    // inclineType에 따른 색상 반환
    function getColorByInclineType(inclineType) {
        switch (inclineType) {
            case 'UPHILL':
                return '#FF0000';
            case 'FLAT':
                return '#00FF00';
            case 'DOWNHILL':
                return '#0000FF';
            default:
                return '#808080';
        }
    }

    // 지도에 코스 그리기
    function drawCourseOnMap() {
        try {
            console.log('drawCourseOnMap 시작');
            console.log('course:', course);
            console.log('map:', map);

            // 기존 마커와 폴리라인 제거
            clearMap();

            if (!course || !course.segments || course.segments.length === 0) {
                console.log('코스 데이터 없음:', {course, segments: course?.segments});
                return;
            }

            console.log('세그먼트 개수:', course.segments.length);

            let allCoordinates = [];

            // 각 세그먼트별로 폴리라인 그리기
            course.segments.forEach((segment, segmentIndex) => {
                console.log(`세그먼트 ${segmentIndex}:`, segment);

                if (!segment.coordinates || segment.coordinates.length === 0) {
                    console.log(`세그먼트 ${segmentIndex} 좌표 없음`);
                    return;
                }

                console.log(`세그먼트 ${segmentIndex} 좌표 개수:`, segment.coordinates.length);

                // 좌표 배열을 카카오맵 LatLng 객체로 변환
                const path = segment.coordinates.map(coord => {
                    console.log('좌표:', coord);
                    return new kakao.maps.LatLng(coord.latitude, coord.longitude);
                });

                allCoordinates.push(...path);

                // 폴리라인 생성
                const polyline = new kakao.maps.Polyline({
                    path: path,
                    strokeWeight: 5,
                    strokeColor: getColorByInclineType(segment.inclineType),
                    strokeOpacity: 0.8,
                    strokeStyle: 'solid'
                });

                polyline.setMap(map);
                polylines.push(polyline);
                console.log(`세그먼트 ${segmentIndex} 폴리라인 추가됨`);

                // 각 좌표에 드래그 가능한 마커 추가
                segment.coordinates.forEach((coord, coordIndex) => {
                    const position = new kakao.maps.LatLng(coord.latitude, coord.longitude);

                    const marker = new kakao.maps.Marker({
                        position: position,
                        draggable: true,
                        map: map
                        // image를 설정하지 않아 카카오맵 기본 마커 사용
                    });

                    // 마커 드래그 이벤트
                    kakao.maps.event.addListener(marker, 'dragend', function () {
                        const newPosition = marker.getPosition();
                        onMarkerDragEnd(segmentIndex, coordIndex, newPosition);
                    });

                    // 마커 오른쪽 클릭 이벤트
                    kakao.maps.event.addListener(marker, 'rightclick', function () {
                        openCoordinateModal(segmentIndex, coordIndex);
                    });

                    markers.push({
                        marker: marker,
                        segmentIndex: segmentIndex,
                        coordIndex: coordIndex
                    });
                });
                console.log(`세그먼트 ${segmentIndex} 마커 추가됨`);
            });

            console.log('총 마커 개수:', markers.length);
            console.log('총 폴리라인 개수:', polylines.length);

            // 지도 중심을 코스에 맞추기 (초기 로드 시에만)
            if (isInitialLoad && allCoordinates.length > 0) {
                console.log('지도 중심 설정 중...');
                const bounds = new kakao.maps.LatLngBounds();
                allCoordinates.forEach(coord => bounds.extend(coord));
                map.setBounds(bounds);
                isInitialLoad = false;
                console.log('지도 중심 설정 완료');
            }

            console.log('drawCourseOnMap 완료');
        } catch (error) {
            console.error('drawCourseOnMap 에러:', error);
            console.error('Error stack:', error.stack);
            showMessage('지도에 코스를 그리는 중 오류가 발생했습니다: ' + error.message, 'error');
        }
    }

    // 마커 드래그 종료 시 처리
    function onMarkerDragEnd(segmentIndex, coordIndex, newPosition) {
        const segment = course.segments[segmentIndex];
        const isFirstCoord = coordIndex === 0;
        const isLastCoord = coordIndex === segment.coordinates.length - 1;

        // 현재 좌표 업데이트
        segment.coordinates[coordIndex].latitude = newPosition.getLat();
        segment.coordinates[coordIndex].longitude = newPosition.getLng();

        // 업데이트할 세그먼트 인덱스 수집
        const segmentsToUpdate = [segmentIndex];
        const markersToUpdate = [];

        // 세그먼트 경계 좌표인 경우 인접 세그먼트와 마커도 업데이트
        if (isFirstCoord && segmentIndex > 0) {
            // 첫 번째 좌표이고 이전 세그먼트가 있는 경우
            const prevSegment = course.segments[segmentIndex - 1];
            const prevLastIndex = prevSegment.coordinates.length - 1;
            prevSegment.coordinates[prevLastIndex].latitude = newPosition.getLat();
            prevSegment.coordinates[prevLastIndex].longitude = newPosition.getLng();
            segmentsToUpdate.push(segmentIndex - 1);

            // 이전 세그먼트의 마지막 마커 찾아서 위치 업데이트
            const prevMarkerInfo = markers.find(m =>
                    m.segmentIndex === segmentIndex - 1 &&
                    m.coordIndex === prevLastIndex
            );
            if (prevMarkerInfo) {
                prevMarkerInfo.marker.setPosition(newPosition);
            }
        }

        if (isLastCoord && segmentIndex < course.segments.length - 1) {
            // 마지막 좌표이고 다음 세그먼트가 있는 경우
            const nextSegment = course.segments[segmentIndex + 1];
            nextSegment.coordinates[0].latitude = newPosition.getLat();
            nextSegment.coordinates[0].longitude = newPosition.getLng();
            segmentsToUpdate.push(segmentIndex + 1);

            // 다음 세그먼트의 첫 번째 마커 찾아서 위치 업데이트
            const nextMarkerInfo = markers.find(m =>
                    m.segmentIndex === segmentIndex + 1 &&
                    m.coordIndex === 0
            );
            if (nextMarkerInfo) {
                nextMarkerInfo.marker.setPosition(newPosition);
            }
        }

        // 영향받은 세그먼트의 폴리라인만 업데이트
        updateSegmentPolylines(segmentsToUpdate);

        // 변경 알림
        let message = '좌표가 변경되었습니다.';
        if (isFirstCoord && segmentIndex > 0) {
            message += ' (이전 세그먼트와 연결됨)';
        } else if (isLastCoord && segmentIndex < course.segments.length - 1) {
            message += ' (다음 세그먼트와 연결됨)';
        }
        message += ' (자동 저장 기능은 추후 구현 예정)';
        showMessage(message, 'success');
        console.log('Updated course:', course);
    }

    // 특정 세그먼트들의 폴리라인만 업데이트
    function updateSegmentPolylines(segmentIndices) {
        segmentIndices.forEach(segmentIndex => {
            const segment = course.segments[segmentIndex];
            if (!segment || !segment.coordinates || segment.coordinates.length === 0) {
                return;
            }

            // 기존 폴리라인 제거 (해당 세그먼트만)
            const oldPolyline = polylines[segmentIndex];
            if (oldPolyline) {
                oldPolyline.setMap(null);
            }

            // 새 경로로 폴리라인 생성
            const path = segment.coordinates.map(coord =>
                    new kakao.maps.LatLng(coord.latitude, coord.longitude)
            );

            const newPolyline = new kakao.maps.Polyline({
                path: path,
                strokeWeight: 5,
                strokeColor: getColorByInclineType(segment.inclineType),
                strokeOpacity: 0.8,
                strokeStyle: 'solid'
            });

            newPolyline.setMap(map);
            polylines[segmentIndex] = newPolyline;
        });
    }

    // 모든 폴리라인 업데이트
    function updatePolylines() {
        // 기존 폴리라인 제거
        polylines.forEach(polyline => polyline.setMap(null));
        polylines = [];

        // 폴리라인 다시 그리기
        course.segments.forEach(segment => {
            if (!segment.coordinates || segment.coordinates.length === 0) {
                return;
            }

            const path = segment.coordinates.map(coord =>
                    new kakao.maps.LatLng(coord.latitude, coord.longitude)
            );

            const polyline = new kakao.maps.Polyline({
                path: path,
                strokeWeight: 5,
                strokeColor: getColorByInclineType(segment.inclineType),
                strokeOpacity: 0.8,
                strokeStyle: 'solid'
            });

            polyline.setMap(map);
            polylines.push(polyline);
        });
    }

    // 지도 초기화
    function clearMap() {
        markers.forEach(item => item.marker.setMap(null));
        markers = [];
        polylines.forEach(polyline => polyline.setMap(null));
        polylines = [];
    }

    // 변경사항 초기화
    function resetChanges() {
        if (confirm('모든 변경사항을 초기화하시겠습니까?')) {
            course = JSON.parse(JSON.stringify(originalCourse));
            displayCourseInfo();
            displayCoordinatesList();
            drawCourseOnMap();
            showMessage('변경사항이 초기화되었습니다.', 'success');
        }
    }

    // 좌표 선택/해제
    function toggleCoordinate(segIdx, coordIdx) {
        const coordId = `${segIdx}_${coordIdx}`;
        const row = document.getElementById(`coord-row-${coordId}`);
        const checkbox = document.getElementById(`checkbox-${coordId}`);

        // 마커 찾기
        const markerInfo = markers.find(m =>
                m.segmentIndex === segIdx && m.coordIndex === coordIdx
        );

        if (checkbox.checked) {
            selectedCoordinates.add(coordId);
            row.classList.add('selected');
            // 마커 이미지를 선택 이미지로 변경
            if (markerInfo && selectedMarkerImage) {
                markerInfo.marker.setImage(selectedMarkerImage);
                markerInfo.marker.setZIndex(1000);
            }
        } else {
            selectedCoordinates.delete(coordId);
            row.classList.remove('selected');
            // 마커 이미지를 기본 이미지로 변경
            if (markerInfo) {
                if (normalMarkerImage) {
                    markerInfo.marker.setImage(normalMarkerImage);
                } else {
                    // normalMarkerImage가 null이면 기본 마커로 복원
                    markerInfo.marker.setImage(null);
                }
                markerInfo.marker.setZIndex(1);
            }
        }

        updateBulkActionButtons();
        updateSelectAllCheckbox();
    }

    // 전체 선택/해제
    function toggleAllCoordinates() {
        const selectAllCheckbox = document.getElementById('select-all-checkbox');
        const isChecked = selectAllCheckbox.checked;

        course.segments.forEach((segment, segIdx) => {
            segment.coordinates.forEach((coord, coordIdx) => {
                const coordId = `${segIdx}_${coordIdx}`;
                const row = document.getElementById(`coord-row-${coordId}`);
                const checkbox = document.getElementById(`checkbox-${coordId}`);

                // 마커 찾기
                const markerInfo = markers.find(m =>
                        m.segmentIndex === segIdx && m.coordIndex === coordIdx
                );

                if (checkbox) {
                    checkbox.checked = isChecked;
                    if (isChecked) {
                        selectedCoordinates.add(coordId);
                        row.classList.add('selected');
                        // 마커 이미지를 선택 이미지로 변경
                        if (markerInfo && selectedMarkerImage) {
                            markerInfo.marker.setImage(selectedMarkerImage);
                            markerInfo.marker.setZIndex(1000);
                        }
                    } else {
                        selectedCoordinates.delete(coordId);
                        row.classList.remove('selected');
                        // 마커 이미지를 기본 이미지로 변경
                        if (markerInfo) {
                            if (normalMarkerImage) {
                                markerInfo.marker.setImage(normalMarkerImage);
                            } else {
                                // normalMarkerImage가 null이면 기본 마커로 복원
                                markerInfo.marker.setImage(null);
                            }
                            markerInfo.marker.setZIndex(1);
                        }
                    }
                }
            });
        });

        updateBulkActionButtons();
    }

    // 전체 선택 체크박스 상태 업데이트
    function updateSelectAllCheckbox() {
        const selectAllCheckbox = document.getElementById('select-all-checkbox');
        if (!selectAllCheckbox) return;

        const totalCoordinates = course.segments.reduce((sum, segment) =>
                sum + segment.coordinates.length, 0
        );

        if (selectedCoordinates.size === 0) {
            selectAllCheckbox.checked = false;
            selectAllCheckbox.indeterminate = false;
        } else if (selectedCoordinates.size === totalCoordinates) {
            selectAllCheckbox.checked = true;
            selectAllCheckbox.indeterminate = false;
        } else {
            selectAllCheckbox.checked = false;
            selectAllCheckbox.indeterminate = true;
        }
    }

    // 일괄 수정 버튼 상태 업데이트
    function updateBulkActionButtons() {
        const showOnMapBtn = document.getElementById('show-on-map-btn');
        const bulkEditBtn = document.getElementById('bulk-edit-btn');
        const bulkDeleteBtn = document.getElementById('bulk-delete-btn');

        const hasSelection = selectedCoordinates.size > 0;

        if (showOnMapBtn) {
            showOnMapBtn.disabled = !hasSelection;
        }
        if (bulkEditBtn) {
            bulkEditBtn.disabled = !hasSelection;
        }
        if (bulkDeleteBtn) {
            bulkDeleteBtn.disabled = !hasSelection;
        }
    }

    // 선택된 좌표 지도에 표시
    function showSelectedOnMap() {
        if (selectedCoordinates.size === 0) {
            showMessage('선택된 좌표가 없습니다.', 'error');
            return;
        }

        // 모든 마커의 zIndex를 기본값으로 설정
        markers.forEach(item => {
            item.marker.setZIndex(1);
        });

        // 선택된 좌표의 마커만 강조
        const selectedBounds = new kakao.maps.LatLngBounds();
        let selectedCount = 0;

        selectedCoordinates.forEach(coordId => {
            const [segIdx, coordIdx] = coordId.split('_').map(Number);
            const markerInfo = markers.find(m =>
                    m.segmentIndex === segIdx && m.coordIndex === coordIdx
            );

            if (markerInfo) {
                markerInfo.marker.setZIndex(1000);
                const position = markerInfo.marker.getPosition();
                selectedBounds.extend(position);
                selectedCount++;
            }
        });

        if (selectedCount > 0) {
            map.setBounds(selectedBounds);
            showMessage(`${selectedCount}개의 선택된 좌표가 강조되었습니다.`, 'success');
        }
    }

    // 단일 좌표 수정
    function editSingleCoordinate(segIdx, coordIdx) {
        const coord = course.segments[segIdx].coordinates[coordIdx];

        const latitude = prompt('위도를 입력하세요:', coord.latitude.toFixed(6));
        if (latitude === null) return;

        const longitude = prompt('경도를 입력하세요:', coord.longitude.toFixed(6));
        if (longitude === null) return;

        const elevation = prompt('고도(m)를 입력하세요:', coord.elevation.toFixed(1));
        if (elevation === null) return;

        const newLat = parseFloat(latitude);
        const newLng = parseFloat(longitude);
        const newElev = parseFloat(elevation);

        // 유효성 검사
        if (isNaN(newLat) || isNaN(newLng) || isNaN(newElev)) {
            showMessage('잘못된 입력입니다. 숫자를 입력해주세요.', 'error');
            return;
        }

        if (newLat < -90 || newLat > 90) {
            showMessage('위도는 -90 ~ 90 사이의 값이어야 합니다.', 'error');
            return;
        }

        if (newLng < -180 || newLng > 180) {
            showMessage('경도는 -180 ~ 180 사이의 값이어야 합니다.', 'error');
            return;
        }

        // 좌표 업데이트
        coord.latitude = newLat;
        coord.longitude = newLng;
        coord.elevation = newElev;

        // 세그먼트 경계 좌표인 경우 인접 세그먼트도 업데이트
        const segment = course.segments[segIdx];
        const isFirstCoord = coordIdx === 0;
        const isLastCoord = coordIdx === segment.coordinates.length - 1;
        const segmentsToUpdate = [segIdx];

        if (isFirstCoord && segIdx > 0) {
            const prevSegment = course.segments[segIdx - 1];
            const prevLastIndex = prevSegment.coordinates.length - 1;
            prevSegment.coordinates[prevLastIndex].latitude = newLat;
            prevSegment.coordinates[prevLastIndex].longitude = newLng;
            prevSegment.coordinates[prevLastIndex].elevation = newElev;
            segmentsToUpdate.push(segIdx - 1);
        }

        if (isLastCoord && segIdx < course.segments.length - 1) {
            const nextSegment = course.segments[segIdx + 1];
            nextSegment.coordinates[0].latitude = newLat;
            nextSegment.coordinates[0].longitude = newLng;
            nextSegment.coordinates[0].elevation = newElev;
            segmentsToUpdate.push(segIdx + 1);
        }

        // 지도의 마커 위치 업데이트
        const newPosition = new kakao.maps.LatLng(newLat, newLng);
        const markerInfo = markers.find(m =>
                m.segmentIndex === segIdx && m.coordIndex === coordIdx
        );
        if (markerInfo) {
            markerInfo.marker.setPosition(newPosition);
        }

        // 인접 마커들도 업데이트
        if (isFirstCoord && segIdx > 0) {
            const prevSegment = course.segments[segIdx - 1];
            const prevLastIndex = prevSegment.coordinates.length - 1;
            const prevMarkerInfo = markers.find(m =>
                    m.segmentIndex === segIdx - 1 && m.coordIndex === prevLastIndex
            );
            if (prevMarkerInfo) {
                prevMarkerInfo.marker.setPosition(newPosition);
            }
        }

        if (isLastCoord && segIdx < course.segments.length - 1) {
            const nextMarkerInfo = markers.find(m =>
                    m.segmentIndex === segIdx + 1 && m.coordIndex === 0
            );
            if (nextMarkerInfo) {
                nextMarkerInfo.marker.setPosition(newPosition);
            }
        }

        // 폴리라인 업데이트
        updateSegmentPolylines(segmentsToUpdate);

        // UI 업데이트
        displayCoordinatesList();
        showMessage('좌표가 수정되었습니다.', 'success');
    }

    // 일괄 수정
    function bulkEditCoordinates() {
        if (selectedCoordinates.size === 0) {
            showMessage('선택된 좌표가 없습니다.', 'error');
            return;
        }

        const elevationOffset = prompt(`${selectedCoordinates.size}개의 선택된 좌표의 고도를 일괄 수정합니다.\n고도 변경값(m)을 입력하세요 (예: +10, -5):`, '+0');
        if (elevationOffset === null) return;

        const offset = parseFloat(elevationOffset);
        if (isNaN(offset)) {
            showMessage('잘못된 입력입니다. 숫자를 입력해주세요.', 'error');
            return;
        }

        // 선택된 좌표들의 고도 일괄 수정
        const updatedSegments = new Set();
        selectedCoordinates.forEach(coordId => {
            const [segIdx, coordIdx] = coordId.split('_').map(Number);
            const coord = course.segments[segIdx].coordinates[coordIdx];
            coord.elevation += offset;
            updatedSegments.add(segIdx);

            // 세그먼트 경계 좌표인 경우 인접 세그먼트도 체크
            const segment = course.segments[segIdx];
            const isFirstCoord = coordIdx === 0;
            const isLastCoord = coordIdx === segment.coordinates.length - 1;

            if (isFirstCoord && segIdx > 0) {
                const prevSegment = course.segments[segIdx - 1];
                const prevLastIndex = prevSegment.coordinates.length - 1;
                prevSegment.coordinates[prevLastIndex].elevation = coord.elevation;
                updatedSegments.add(segIdx - 1);
            }

            if (isLastCoord && segIdx < course.segments.length - 1) {
                const nextSegment = course.segments[segIdx + 1];
                nextSegment.coordinates[0].elevation = coord.elevation;
                updatedSegments.add(segIdx + 1);
            }
        });

        // UI 업데이트
        displayCoordinatesList();
        showMessage(`${selectedCoordinates.size}개 좌표의 고도가 ${offset > 0 ? '+' : ''}${offset}m 변경되었습니다.`, 'success');
    }

    // 일괄 삭제
    function bulkDeleteCoordinates() {
        if (selectedCoordinates.size === 0) {
            showMessage('선택된 좌표가 없습니다.', 'error');
            return;
        }

        // 전체 좌표 수 계산
        const totalCoordinates = course.segments.reduce((sum, segment) =>
                sum + segment.coordinates.length, 0
        );

        // 삭제 후 남을 좌표 수 확인
        const remainingCoordinates = totalCoordinates - selectedCoordinates.size;
        if (remainingCoordinates < 2) {
            showMessage(`코스는 최소 2개 이상의 좌표가 필요합니다. (현재: ${totalCoordinates}개, 선택: ${selectedCoordinates.size}개)`, 'error');
            return;
        }

        if (!confirm(`정말로 선택한 ${selectedCoordinates.size}개의 좌표를 삭제하시겠습니까?`)) {
            return;
        }

        // 삭제할 좌표를 세그먼트별로 그룹화 (역순으로 정렬하여 인덱스 변경 문제 방지)
        const coordsToDelete = Array.from(selectedCoordinates).map(coordId => {
            const [segIdx, coordIdx] = coordId.split('_').map(Number);
            return {segIdx, coordIdx};
        }).sort((a, b) => {
            // 세그먼트 인덱스 역순, 같은 세그먼트 내에서는 좌표 인덱스 역순
            if (a.segIdx !== b.segIdx) {
                return b.segIdx - a.segIdx;
            }
            return b.coordIdx - a.coordIdx;
        });

        // 세그먼트 경계 좌표 처리를 위한 Set
        const processedBoundaries = new Set();

        // 역순으로 삭제 (인덱스 변경 문제 방지)
        coordsToDelete.forEach(({segIdx, coordIdx}) => {
            const segment = course.segments[segIdx];
            if (!segment || !segment.coordinates[coordIdx]) {
                return; // 이미 삭제된 경우 스킵
            }

            const isFirstCoord = coordIdx === 0;
            const isLastCoord = coordIdx === segment.coordinates.length - 1;
            const boundaryKey = `${segIdx}_${coordIdx}`;

            // 세그먼트 경계 좌표인 경우 인접 세그먼트에서도 삭제
            if (isFirstCoord && segIdx > 0 && !processedBoundaries.has(boundaryKey)) {
                const prevSegment = course.segments[segIdx - 1];
                if (prevSegment && prevSegment.coordinates.length > 0) {
                    prevSegment.coordinates.pop(); // 마지막 좌표 제거
                    processedBoundaries.add(boundaryKey);
                }
            }

            if (isLastCoord && segIdx < course.segments.length - 1 && !processedBoundaries.has(boundaryKey)) {
                const nextSegment = course.segments[segIdx + 1];
                if (nextSegment && nextSegment.coordinates.length > 0) {
                    nextSegment.coordinates.shift(); // 첫 번째 좌표 제거
                    processedBoundaries.add(boundaryKey);
                }
            }

            // 현재 세그먼트에서 좌표 삭제
            segment.coordinates.splice(coordIdx, 1);
        });

        // 빈 세그먼트 제거 (역순으로)
        for (let i = course.segments.length - 1; i >= 0; i--) {
            if (course.segments[i].coordinates.length === 0) {
                course.segments.splice(i, 1);
            }
        }

        // 선택된 좌표 초기화
        selectedCoordinates.clear();

        // 지도 다시 그리기
        drawCourseOnMap();

        // UI 업데이트
        displayCourseInfo();
        displayCoordinatesList();
        showMessage(`${coordsToDelete.length}개의 좌표가 삭제되었습니다.`, 'success');
    }

    // 코스 이름 업데이트
    function updateCourseName(newName) {
        if (!course) {
            showMessage('코스 정보를 찾을 수 없습니다.', 'error');
            return;
        }

        // 빈 문자열 체크
        if (!newName.trim()) {
            showMessage('코스 이름을 입력해주세요.', 'error');
            // 이전 값으로 복원
            const nameInput = document.getElementById('course-name-input');
            if (nameInput) {
                nameInput.value = course.name;
            }
            return;
        }

        // 코스 이름 업데이트
        course.name = newName.trim();
        showMessage('코스 이름이 변경되었습니다.', 'success');
        console.log('코스 이름 변경:', course.name);
    }

    // 도로 타입 업데이트
    function updateRoadType(newRoadType) {
        if (!course) {
            showMessage('코스 정보를 찾을 수 없습니다.', 'error');
            return;
        }

        // 유효한 도로 타입인지 확인
        const validRoadTypes = ['트랙', '트레일', '보도', '알수없음'];
        if (!validRoadTypes.includes(newRoadType)) {
            showMessage('유효하지 않은 도로 타입입니다.', 'error');
            // 이전 값으로 복원
            const roadTypeSelect = document.getElementById('road-type-select');
            if (roadTypeSelect) {
                roadTypeSelect.value = course.roadType;
            }
            return;
        }

        // 도로 타입 업데이트
        course.roadType = newRoadType;
        showMessage('도로 타입이 변경되었습니다.', 'success');
        console.log('도로 타입 변경:', course.roadType);
    }

    // 코스 저장
    async function saveCourse() {
        if (!course) {
            showMessage('저장할 코스가 없습니다.', 'error');
            return;
        }

        if (!confirm('변경사항을 저장하시겠습니까?')) {
            return;
        }

        // 저장 버튼 비활성화
        const saveButton = document.querySelector('.save-button');
        if (saveButton) {
            saveButton.disabled = true;
            saveButton.textContent = '저장 중...';
        }

        try {
            console.log('=== 저장할 코스 데이터 ===');
            console.log('Course ID:', courseId);
            console.log('Course Data:', JSON.stringify(course, null, 2));

            // 모든 세그먼트의 좌표를 평탄화하여 [[lat, lng, elev], ...] 형식으로 변환
            const coordinates = [];
            course.segments.forEach(segment => {
                segment.coordinates.forEach(coord => {
                    coordinates.push([
                        coord.latitude,
                        coord.longitude,
                        coord.elevation
                    ]);
                });
            });

            // API 요청 데이터 준비
            const requestData = {
                coordinates: coordinates,
                name: course.name,
                roadType: course.roadType
            };

            console.log('=== API 요청 데이터 ===');
            console.log('Request Data:', JSON.stringify(requestData, null, 2));

            // API 호출
            const response = await axios.patch(`/admin/courses/${courseId}`, requestData, {
                headers: {
                    'Content-Type': 'application/json'
                },
                withCredentials: true
            });

            if (response.status === 200) {
                // 저장 성공 시 originalCourse 업데이트
                originalCourse = JSON.parse(JSON.stringify(course));
                showMessage('코스가 성공적으로 저장되었습니다.', 'success');
                console.log('코스 저장 성공');
            }

        } catch (error) {
            console.error('코스 저장 실패:', error);
            if (error.response && error.response.status === 401) {
                alert('로그인 세션이 만료되었습니다.');
                window.location.href = '/admin/login';
            } else if (error.response && error.response.status === 403) {
                alert('권한이 없습니다. 관리자 로그인이 필요합니다.');
                window.location.href = '/admin/login';
            } else {
                const errorMessage = error.response?.data?.message || error.message || '알 수 없는 오류';
                showMessage('코스 저장에 실패했습니다: ' + errorMessage, 'error');
            }
        } finally {
            // 저장 버튼 활성화
            if (saveButton) {
                saveButton.disabled = false;
                saveButton.textContent = '저장';
            }
        }
    }

    // 좌표 수정 모달 열기
    function openCoordinateModal(segIdx, coordIdx) {
        const coord = course.segments[segIdx].coordinates[coordIdx];

        // 현재 수정 중인 좌표 정보 저장
        currentEditingCoord = {segIdx, coordIdx};

        // 모달 입력 필드에 현재 값 설정
        document.getElementById('modal-latitude').value = coord.latitude.toFixed(6);
        document.getElementById('modal-longitude').value = coord.longitude.toFixed(6);
        document.getElementById('modal-elevation').value = coord.elevation.toFixed(1);

        // 모달 표시
        const modal = document.getElementById('coordinate-edit-modal');
        modal.classList.add('active');

        // 첫 번째 입력 필드에 포커스
        setTimeout(() => {
            document.getElementById('modal-latitude').focus();
        }, 100);
    }

    // 좌표 수정 모달 닫기
    function closeCoordinateModal() {
        const modal = document.getElementById('coordinate-edit-modal');
        modal.classList.remove('active');
        currentEditingCoord = null;
    }

    // 모달에서 좌표 저장
    function saveCoordinateFromModal() {
        if (!currentEditingCoord) {
            showMessage('수정할 좌표 정보가 없습니다.', 'error');
            return;
        }

        const {segIdx, coordIdx} = currentEditingCoord;

        // 입력값 가져오기
        const newLat = parseFloat(document.getElementById('modal-latitude').value);
        const newLng = parseFloat(document.getElementById('modal-longitude').value);
        const newElev = parseFloat(document.getElementById('modal-elevation').value);

        // 유효성 검사
        if (isNaN(newLat) || isNaN(newLng) || isNaN(newElev)) {
            showMessage('잘못된 입력입니다. 숫자를 입력해주세요.', 'error');
            return;
        }

        if (newLat < -90 || newLat > 90) {
            showMessage('위도는 -90 ~ 90 사이의 값이어야 합니다.', 'error');
            return;
        }

        if (newLng < -180 || newLng > 180) {
            showMessage('경도는 -180 ~ 180 사이의 값이어야 합니다.', 'error');
            return;
        }

        // 좌표 업데이트
        const coord = course.segments[segIdx].coordinates[coordIdx];
        coord.latitude = newLat;
        coord.longitude = newLng;
        coord.elevation = newElev;

        // 세그먼트 경계 좌표인 경우 인접 세그먼트도 업데이트
        const segment = course.segments[segIdx];
        const isFirstCoord = coordIdx === 0;
        const isLastCoord = coordIdx === segment.coordinates.length - 1;
        const segmentsToUpdate = [segIdx];

        if (isFirstCoord && segIdx > 0) {
            const prevSegment = course.segments[segIdx - 1];
            const prevLastIndex = prevSegment.coordinates.length - 1;
            prevSegment.coordinates[prevLastIndex].latitude = newLat;
            prevSegment.coordinates[prevLastIndex].longitude = newLng;
            prevSegment.coordinates[prevLastIndex].elevation = newElev;
            segmentsToUpdate.push(segIdx - 1);
        }

        if (isLastCoord && segIdx < course.segments.length - 1) {
            const nextSegment = course.segments[segIdx + 1];
            nextSegment.coordinates[0].latitude = newLat;
            nextSegment.coordinates[0].longitude = newLng;
            nextSegment.coordinates[0].elevation = newElev;
            segmentsToUpdate.push(segIdx + 1);
        }

        // 지도의 마커 위치 업데이트
        const newPosition = new kakao.maps.LatLng(newLat, newLng);
        const markerInfo = markers.find(m =>
                m.segmentIndex === segIdx && m.coordIndex === coordIdx
        );
        if (markerInfo) {
            markerInfo.marker.setPosition(newPosition);
        }

        // 인접 마커들도 업데이트
        if (isFirstCoord && segIdx > 0) {
            const prevSegment = course.segments[segIdx - 1];
            const prevLastIndex = prevSegment.coordinates.length - 1;
            const prevMarkerInfo = markers.find(m =>
                    m.segmentIndex === segIdx - 1 && m.coordIndex === prevLastIndex
            );
            if (prevMarkerInfo) {
                prevMarkerInfo.marker.setPosition(newPosition);
            }
        }

        if (isLastCoord && segIdx < course.segments.length - 1) {
            const nextMarkerInfo = markers.find(m =>
                    m.segmentIndex === segIdx + 1 && m.coordIndex === 0
            );
            if (nextMarkerInfo) {
                nextMarkerInfo.marker.setPosition(newPosition);
            }
        }

        // 폴리라인 업데이트
        updateSegmentPolylines(segmentsToUpdate);

        // UI 업데이트
        displayCoordinatesList();
        showMessage('좌표가 수정되었습니다.', 'success');

        // 모달 닫기
        closeCoordinateModal();
    }

    // 모달에서 좌표 삭제
    function deleteCoordinateFromModal() {
        if (!currentEditingCoord) {
            showMessage('삭제할 좌표 정보가 없습니다.', 'error');
            return;
        }

        const {segIdx, coordIdx} = currentEditingCoord;

        if (!confirm('정말로 이 좌표를 삭제하시겠습니까?')) {
            return;
        }

        // 전체 좌표 수 계산
        const totalCoordinates = course.segments.reduce((sum, segment) =>
                sum + segment.coordinates.length, 0
        );

        // 최소 좌표 수 검증 (최소 2개 필요)
        if (totalCoordinates <= 2) {
            showMessage('코스는 최소 2개 이상의 좌표가 필요합니다.', 'error');
            return;
        }

        // 좌표 삭제
        const segment = course.segments[segIdx];
        const isFirstCoord = coordIdx === 0;
        const isLastCoord = coordIdx === segment.coordinates.length - 1;

        // 세그먼트 경계 좌표인 경우 인접 세그먼트에서도 삭제
        if (isFirstCoord && segIdx > 0) {
            const prevSegment = course.segments[segIdx - 1];
            prevSegment.coordinates.pop(); // 마지막 좌표 제거
        }

        if (isLastCoord && segIdx < course.segments.length - 1) {
            const nextSegment = course.segments[segIdx + 1];
            nextSegment.coordinates.shift(); // 첫 번째 좌표 제거
        }

        // 현재 세그먼트에서 좌표 삭제
        segment.coordinates.splice(coordIdx, 1);

        // 세그먼트가 비어있으면 세그먼트도 제거
        if (segment.coordinates.length === 0) {
            course.segments.splice(segIdx, 1);
        }

        // 선택된 좌표 Set에서 제거
        const coordId = `${segIdx}_${coordIdx}`;
        selectedCoordinates.delete(coordId);

        // 지도 다시 그리기
        drawCourseOnMap();

        // UI 업데이트
        displayCourseInfo();
        displayCoordinatesList();
        showMessage('좌표가 삭제되었습니다.', 'success');

        // 모달 닫기
        closeCoordinateModal();
    }

    // 모달 외부 클릭 시 닫기
    document.getElementById('coordinate-edit-modal').addEventListener('click', function (e) {
        if (e.target === this) {
            closeCoordinateModal();
        }
    });

    // ESC 키로 모달 닫기
    document.addEventListener('keydown', function (e) {
        if (e.key === 'Escape') {
            const modal = document.getElementById('coordinate-edit-modal');
            if (modal.classList.contains('active')) {
                closeCoordinateModal();
            }
        }
    });

    // Enter 키로 모달 저장
    document.getElementById('coordinate-edit-modal').addEventListener('keydown', function (e) {
        if (e.key === 'Enter' && this.classList.contains('active')) {
            e.preventDefault();
            saveCoordinateFromModal();
        }
    });
</script>
</body>
</html>
